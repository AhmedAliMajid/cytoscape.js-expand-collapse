(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.cytoscapeExpandCollapse = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
var boundingBoxUtilities = {
  equalBoundingBoxes: function(bb1, bb2){
      return bb1.x1 == bb2.x1 && bb1.x2 == bb2.x2 && bb1.y1 == bb2.y1 && bb1.y2 == bb2.y2;
  },
  getUnion: function(bb1, bb2){
      var union = {
      x1: Math.min(bb1.x1, bb2.x1),
      x2: Math.max(bb1.x2, bb2.x2),
      y1: Math.min(bb1.y1, bb2.y1),
      y2: Math.max(bb1.y2, bb2.y2),
    };

    union.w = union.x2 - union.x1;
    union.h = union.y2 - union.y1;

    return union;
  }
};

module.exports = boundingBoxUtilities;
},{}],2:[function(_dereq_,module,exports){
var boundingBoxUtilities = _dereq_('./boundingBoxUtilities');

// Expand collapse utilities
var expandCollapseUtilities = {
  edgesToRepair: null,
  //the number of nodes moving animatedly after expand operation
  animatedlyMovingNodeCount: 0,
  //This is a map which keeps the information of collapsed meta edges to handle them correctly
  collapsedMetaEdgesInfo: {},
  //This map keeps track of the meta levels of edges by their id's
  edgesMetaLevels: {},
  moveNodes: function (positionDiff, nodes, notCalcTopMostNodes) {
    var topMostNodes = notCalcTopMostNodes ? nodes : this.getTopMostNodes(nodes);
    for (var i = 0; i < topMostNodes.length; i++) {
      var node = topMostNodes[i];
      var oldX = node.position("x");
      var oldY = node.position("y");
      node.position({
        x: oldX + positionDiff.x,
        y: oldY + positionDiff.y
      });
      var children = node.children();
      this.moveNodes(positionDiff, children, true);
    }
  },
  getTopMostNodes: function (nodes) {//*//
    var nodesMap = {};
    for (var i = 0; i < nodes.length; i++) {
      nodesMap[nodes[i].id()] = true;
    }
    var roots = nodes.filter(function (i, ele) {
      var parent = ele.parent()[0];
      while (parent != null) {
        if (nodesMap[parent.id()]) {
          return false;
        }
        parent = parent.parent()[0];
      }
      return true;
    });

    return roots;
  },
  rearrange: function (layoutBy) {//*//
    if (typeof layoutBy === "function") {
      layoutBy();
    } else if (layoutBy != null) {
      cy.layout(layoutBy);
    }
  },
  //This method changes source or target id of the collapsed edge data kept in the data of the node
  //with id of createdWhileBeingCollapsed
  alterSourceOrTargetOfCollapsedEdge: function (createdWhileBeingCollapsed, edgeId, sourceOrTarget) {//*//
    var node = cy.getElementById(createdWhileBeingCollapsed)[0];
    var edgesOfcollapsedChildren = node._private.data.edgesOfcollapsedChildren;
    for (var i = 0; i < edgesOfcollapsedChildren.length; i++) {
      var collapsedEdge = edgesOfcollapsedChildren[i];
      if (collapsedEdge._private.data.id == edgeId) {
        collapsedEdge._private.data[sourceOrTarget] = collapsedEdge._private.data.collapsedNodeBeforeBecamingMeta;
        break;
      }
    }
  },
  //A funtion basicly expanding a node it is to be called when a node is expanded anyway
  expandNodeBaseFunction: function (node, triggerLayout, single, layoutBy) {//*//
    //check how the position of the node is changed
    var positionDiff = {
      x: node.position('x') - node.data('position-before-collapse').x,
      y: node.position('y') - node.data('position-before-collapse').y
    };

    node.removeData("infoLabel");
    node.data('expanded-collapsed', 'expanded');
    node._private.data.collapsedChildren.nodes().restore();
    this.repairEdgesOfCollapsedChildren(node);
    node._private.data.collapsedChildren = null;

    cy.nodes().updateCompoundBounds();

    //Don't show children info when the complex node is expanded
    if (node._private.data.sbgnclass == "complex") {
      node.removeStyle('content');
    }

    this.moveNodes(positionDiff, node.children());
    node.removeData('position-before-collapse');

    if (single)
      this.endOperation();
    // refreshPaddings();
    if (triggerLayout) { //*/*/*asdsadda
      this.rearrange(layoutBy);

    }
  },
  simpleCollapseGivenNodes: function (nodes) {//*//
    nodes.data("collapse", true);
    var roots = this.getTopMostNodes(nodes);
    for (var i = 0; i < roots.length; i++) {
      var root = roots[i];
      this.collapseBottomUp(root);
    }
    return nodes;
  },
  simpleExpandGivenNodes: function (nodes, applyFishEyeViewToEachNode) {//*//
    nodes.data("expand", true);
    var roots = this.getTopMostNodes(nodes);
    for (var i = 0; i < roots.length; i++) {
      var root = roots[i];
      this.expandTopDown(root, applyFishEyeViewToEachNode);
    }
    return nodes;
  },
  simpleExpandAllNodes: function (nodes, applyFishEyeViewToEachNode) {//*//
    if (nodes === undefined) {
      nodes = cy.nodes();
    }
    var orphans;
    console.log(this.getTopMostNodes(nodes).map(function (e) {
      return e.id();
    }), nodes.orphans().map(function (e) {
      return e.id();
    }));
    orphans = this.getTopMostNodes(nodes);
    var expandStack = [];
    for (var i = 0; i < orphans.length; i++) {
      var root = orphans[i];
      this.expandAllTopDown(root, expandStack, applyFishEyeViewToEachNode);
    }
    return expandStack;
  },
  beginOperation: function () {
    this.edgesToRepair = cy.collection();
  },
  endOperation: function () {
    this.edgesToRepair.restore();
    for (var i = 0; i < this.edgesToRepair.length; i++) {
      var edge = this.edgesToRepair[i];
      if (this.edgesMetaLevels[edge.id()] == null || this.edgesMetaLevels[edge.id()] == 0) {
        edge.removeClass("meta");
      }
      else {
        edge.addClass("meta");
      }
    }
    this.edgesToRepair = cy.collection();
  },
  expandAllNodes: function (nodes, options) {//*//
    this.beginOperation();
    cy.trigger("beforeExpand", [nodes, options]);
    var expandedStack = this.simpleExpandAllNodes(nodes, options.fisheye);
    cy.trigger("afterExpand", [nodes, options]);

    this.endOperation();

    this.rearrange(options.layoutBy);

    /*
     * return the nodes to undo the operation
     */
    return expandedStack;
  },
  expandAllTopDown: function (root, expandStack, applyFishEyeViewToEachNode) {//*//
    if (root._private.data.collapsedChildren != null) {
      expandStack.push(root);
      this.simpleExpandNode(root, applyFishEyeViewToEachNode);
    }
    var children = root.children();
    for (var i = 0; i < children.length; i++) {
      var node = children[i];
      this.expandAllTopDown(node, expandStack, applyFishEyeViewToEachNode);
    }
  },
  //Expand the given nodes perform incremental layout after expandation
  expandGivenNodes: function (nodes, options) {//*//
    this.beginOperation();
    cy.trigger("beforeExpand", [nodes, options]);
    if (nodes.length === 1) {
      this.expandNode(nodes[0], options.fisheye, options.animate, options.layoutBy);
      cy.trigger("afterExpand", [nodes, options]);

    } else {
      this.simpleExpandGivenNodes(nodes, options.fisheye);
      this.endOperation();
      cy.trigger("afterExpand", [nodes, options]);

      this.rearrange(options.layoutBy);
    }

    /*
     * return the nodes to undo the operation
     */
    return nodes;
  },
  //collapse the given nodes then make incremental layout
  collapseGivenNodes: function (nodes, options) {//*//
    this.beginOperation();
    cy.trigger("beforeCollapse", [nodes, options]);
    this.simpleCollapseGivenNodes(nodes, options);
    cy.trigger("beforeCollapse", [nodes, options]);

    this.endOperation();
    this.rearrange(options.layoutBy);

    /*
     * return the nodes to undo the operation
     */
    return nodes;
  },
  //collapse the nodes in bottom up order starting from the root
  collapseBottomUp: function (root) {//*//
    var children = root.children();
    for (var i = 0; i < children.length; i++) {
      var node = children[i];
      this.collapseBottomUp(node);
    }
    //If the root is a compound node to be collapsed then collapse it
    if (root.data("collapse") && root.children().length > 0) {
      this.simpleCollapseNode(root);
      root.removeData("collapse");
    }
  },
  //expand the nodes in top down order starting from the root
  expandTopDown: function (root, applyFishEyeViewToEachNode) {//*//
    if (root.data("expand") && root._private.data.collapsedChildren != null) {
      this.simpleExpandNode(root, applyFishEyeViewToEachNode);
      root.removeData("expand");
    }
    var children = root.children();
    for (var i = 0; i < children.length; i++) {
      var node = children[i];
      this.expandTopDown(node);
    }
  },
  expandNode: function (node, fisheye, animate, layoutBy) {
    if (node._private.data.collapsedChildren != null) {
      this.simpleExpandNode(node, fisheye, true, animate, layoutBy);

      /*
       * return the node to undo the operation
       */
      return node;
    }
  },
  convertToModelPosition: function (renderedPosition) {
    var pan = cy.pan();
    var zoom = cy.zoom();

    var x = (renderedPosition.x - pan.x) / zoom;
    var y = (renderedPosition.y - pan.y) / zoom;

    return {
      x: x,
      y: y
    };
  },
  /*
   *
   * This method expands the given node
   * without making incremental layout
   * after expand operation it will be simply
   * used to undo the collapse operation
   */
  simpleExpandNode: function (node, applyFishEyeViewToEachNode, singleNotSimple, animate, layoutBy) {//*//
    var self = this;

    var commonExpandOperation = function (node, applyFishEyeViewToEachNode, singleNotSimple, animate, layoutBy) {
      if (applyFishEyeViewToEachNode) {

        node.data('width-before-fisheye', node.data('size-before-collapse').w);
        node.data('height-before-fisheye', node.data('size-before-collapse').h);

        self.fishEyeViewExpandGivenNode(node, singleNotSimple, node, animate, layoutBy);
      }

      if (!singleNotSimple || !applyFishEyeViewToEachNode || !animate) {
        self.expandNodeBaseFunction(node, singleNotSimple, singleNotSimple, layoutBy); //*****
      }
    };

    if (node._private.data.collapsedChildren != null) {
      this.storeWidthHeight(node);
      if (applyFishEyeViewToEachNode && singleNotSimple) {
        var topLeftPosition = this.convertToModelPosition({x: 0, y: 0});
        var bottomRightPosition = this.convertToModelPosition({x: cy.width(), y: cy.height()});
        var padding = 80;
        var bb = {
          x1: topLeftPosition.x,
          x2: bottomRightPosition.x,
          y1: topLeftPosition.y,
          y2: bottomRightPosition.y
        };

        var nodeBB = {
          x1: node.position('x') - node.data('size-before-collapse').w / 2 - padding,
          x2: node.position('x') + node.data('size-before-collapse').w / 2 + padding,
          y1: node.position('y') - node.data('size-before-collapse').h / 2 - padding,
          y2: node.position('y') + node.data('size-before-collapse').h / 2 + padding
        };

        var unionBB = boundingBoxUtilities.getUnion(nodeBB, bb);
        var animating = false;

        if (!boundingBoxUtilities.equalBoundingBoxes(unionBB, bb)) {
          var viewPort = cy.getFitViewport(unionBB, 10);
          var self = this;
          animating = animate;
          if (animate) {
            cy.animate({
              pan: viewPort.pan,
              zoom: viewPort.zoom,
              complete: function () {
                commonExpandOperation(node, applyFishEyeViewToEachNode, singleNotSimple, animate, layoutBy);
              }
            }, {
              duration: 1000
            });
            console.log("animate");
          }
          else {
            console.log("zoom");
            cy.zoom(viewPort.zoom);
            cy.pan(viewPort.pan);
          }
        }
        if (!animating) {
          console.log("animating");
          commonExpandOperation(node, applyFishEyeViewToEachNode, singleNotSimple, animate, layoutBy);
        }
      }
      else {
        commonExpandOperation(node, applyFishEyeViewToEachNode, singleNotSimple, animate, layoutBy);
      }

      //return the node to undo the operation
      return node;
    }
  },
  //collapse the given node without making incremental layout
  simpleCollapseNode: function (node) {//*//
    if (node._private.data.collapsedChildren == null) {
      node.data('position-before-collapse', {
        x: node.position().x,
        y: node.position().y
      });

      node.data('size-before-collapse', {
        w: node.outerWidth(),
        h: node.outerHeight()
      });

      node.children().unselect();
      node.children().connectedEdges().unselect();

      node.data('expanded-collapsed', 'collapsed');

      var children = node.children();


      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        this.barrowEdgesOfcollapsedChildren(node, child);
      }

      this.removeChildren(node, node);
      // refreshPaddings();

      if (node._private.data.sbgnclass == "complex") {
        node.addClass('changeContent');
      }

      node.position(node.data('position-before-collapse'));

      //return the node to undo the operation
      return node;
    }
  },
  storeWidthHeight: function (node) {//*//
    if (node != null) {
      node.data('x-before-fisheye', this.xPositionInParent(node));
      node.data('y-before-fisheye', this.yPositionInParent(node));
      node.data('width-before-fisheye', node.outerWidth());
      node.data('height-before-fisheye', node.outerHeight());

      if (node.parent()[0] != null) {
        this.storeWidthHeight(node.parent()[0]);
      }
    }

  },
  fishEyeViewExpandGivenNode: function (node, singleNotSimple, nodeToExpand, animate, layoutBy) {//*//
    var siblings = this.getSiblings(node);

    var x_a = this.xPositionInParent(node);
    var y_a = this.yPositionInParent(node);

    var d_x_left = Math.abs((node.data('width-before-fisheye') - node.outerWidth()) / 2);
    var d_x_right = Math.abs((node.data('width-before-fisheye') - node.outerWidth()) / 2);
    var d_y_upper = Math.abs((node.data('height-before-fisheye') - node.outerHeight()) / 2);
    var d_y_lower = Math.abs((node.data('height-before-fisheye') - node.outerHeight()) / 2);

    var abs_diff_on_x = Math.abs(node.data('x-before-fisheye') - x_a);
    var abs_diff_on_y = Math.abs(node.data('y-before-fisheye') - y_a);

    // Center went to LEFT
    if (node.data('x-before-fisheye') > x_a) {
      d_x_left = d_x_left + abs_diff_on_x;
      d_x_right = d_x_right - abs_diff_on_x;
    }
    // Center went to RIGHT
    else {
      d_x_left = d_x_left - abs_diff_on_x;
      d_x_right = d_x_right + abs_diff_on_x;
    }

    // Center went to UP
    if (node.data('y-before-fisheye') > y_a) {
      d_y_upper = d_y_upper + abs_diff_on_y;
      d_y_lower = d_y_lower - abs_diff_on_y;
    }
    // Center went to DOWN
    else {
      d_y_upper = d_y_upper - abs_diff_on_y;
      d_y_lower = d_y_lower + abs_diff_on_y;
    }

    var xPosInParentSibling = [];
    var yPosInParentSibling = [];

    for (var i = 0; i < siblings.length; i++) {
      xPosInParentSibling.push(this.xPositionInParent(siblings[i]));
      yPosInParentSibling.push(this.yPositionInParent(siblings[i]));
    }

    for (var i = 0; i < siblings.length; i++) {
      var sibling = siblings[i];

      var x_b = xPosInParentSibling[i];
      var y_b = yPosInParentSibling[i];

      var slope = (y_b - y_a) / (x_b - x_a);

      var d_x = 0;
      var d_y = 0;
      var T_x = 0;
      var T_y = 0;

      // Current sibling is on the LEFT
      if (x_a > x_b) {
        d_x = d_x_left;
      }
      // Current sibling is on the RIGHT
      else {
        d_x = d_x_right;
      }
      // Current sibling is on the UPPER side
      if (y_a > y_b) {
        d_y = d_y_upper;
      }
      // Current sibling is on the LOWER side
      else {
        d_y = d_y_lower;
      }

      if (isFinite(slope)) {
        T_x = Math.min(d_x, (d_y / Math.abs(slope)));
      }

      if (slope !== 0) {
        T_y = Math.min(d_y, (d_x * Math.abs(slope)));
      }

      if (x_a > x_b) {
        T_x = -1 * T_x;
      }

      if (y_a > y_b) {
        T_y = -1 * T_y;
      }

      this.fishEyeViewMoveNode(sibling, T_x, T_y, nodeToExpand, singleNotSimple, animate, layoutBy);
    }


    if (node.parent()[0] != null) {
      this.fishEyeViewExpandGivenNode(node.parent()[0], singleNotSimple, nodeToExpand, animate, layoutBy);
    }

    return node;
  },
  getSiblings: function (node) {//*//
    var siblings;

    if (node.parent()[0] == null) {
      siblings = cy.collection();
      var orphans = cy.nodes().orphans();

      for (var i = 0; i < orphans.length; i++) {
        if (orphans[i] != node) {
          siblings = siblings.add(orphans[i]);
        }
      }
    } else {
      siblings = node.siblings();
    }

    return siblings;
  },
  /*
   * Move node operation specialized for fish eye view expand operation
   * Moves the node by moving its descandents. Movement is animated if singleNotSimple flag is truthy.
   */
  fishEyeViewMoveNode: function (node, T_x, T_y, nodeToExpand, singleNotSimple, animate, layoutBy) {//*//
    var childrenList = node.children();
    var self = this;

    if (childrenList.length == 0) {
      var newPosition = {x: node.position('x') + T_x, y: node.position('y') + T_y};
      if (!singleNotSimple || !animate) {
        node.position(newPosition);
      }
      else {
        this.animatedlyMovingNodeCount++;
        node.animate({
          position: newPosition,
          complete: function () {
            self.animatedlyMovingNodeCount--;
            if (self.animatedlyMovingNodeCount > 0 || nodeToExpand.data('expanded-collapsed') === 'expanded') {

              return;
            }

            self.expandNodeBaseFunction(nodeToExpand, singleNotSimple, true, layoutBy);

          }
        }, {
          duration: 1000
        });
      }
    }
    else {

      for (var i = 0; i < childrenList.length; i++) {
        this.fishEyeViewMoveNode(childrenList[i], T_x, T_y, nodeToExpand, singleNotSimple, animate, layoutBy);
      }
    }
  },
  xPositionInParent: function (node) {//*//
    var parent = node.parent()[0];
    var x_a = 0.0;

    // Given node is not a direct child of the the root graph
    if (parent != null) {
      x_a = node.relativePosition('x') + (parent.width() / 2);
    }
    // Given node is a direct child of the the root graph

    else {
      x_a = node.position('x');
    }

    return x_a;
  },
  yPositionInParent: function (node) {//*//
    var parent = node.parent()[0];

    var y_a = 0.0;

    // Given node is not a direct child of the the root graph
    if (parent != null) {
      /*console.log("Node ID: " + node.id());
       console.log("Parent ID: " + parent.id());
       console.log("Parent.width: " + parent.width());
       console.log("Parent.height: " + parent.height());*/
      y_a = node.relativePosition('y') + (parent.height() / 2);
    }
    // Given node is a direct child of the the root graph

    else {
      y_a = node.position('y');
    }

    return y_a;
  },
  /*
   * for all children of the node parameter call this method
   * with the same root parameter,
   * remove the child and add the removed child to the collapsedchildren data
   * of the root to restore them in the case of expandation
   * root._private.data.collapsedChildren keeps the nodes to restore when the
   * root is expanded
   */
  removeChildren: function (node, root) {//*//
    var children = node.children();
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      this.removeChildren(child, root);
      var removedChild = child.remove();
      if (root._private.data.collapsedChildren == null) {
        root._private.data.collapsedChildren = removedChild;
      }
      else {
        root._private.data.collapsedChildren = root._private.data.collapsedChildren.union(removedChild);
      }
    }
  },
  /*
   * This method let the root parameter to barrow the edges connected to the
   * child node or any node inside child node if the any one the source and target
   * is an outer node of the root node in other word it create meta edges
   */
  barrowEdgesOfcollapsedChildren: function (root, childNode) {//*//
    var children = childNode.children();
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      this.barrowEdgesOfcollapsedChildren(root, child);
    }

    var edges = childNode.connectedEdges();
    for (var i = 0; i < edges.length; i++) {
      var edge = edges[i];
      var source = edge.data("source");
      var target = edge.data("target");
      var sourceNode = edge.source();
      var targetNode = edge.target();
      var newEdge = jQuery.extend(true, {}, edge.jsons()[0]);

      //Initilize the meta level of this edge if it is not initilized yet
      if (this.edgesMetaLevels[edge.id()] == null) {
        this.edgesMetaLevels[edge.id()] = 0;
      }

      /*If the edge is meta and has different source and targets then handle this case because if
       * the other end of this edge is removed because of the reason that it's parent is
       * being collapsed and this node is expanded before other end is still collapsed this causes
       * that this edge cannot be restored as one end node of it does not exists.
       * Create a collapsed meta edge info for this edge and add this info to collapsedMetaEdgesInfo
       * map. This info includes createdWhileBeingCollapsed(the node which is being collapsed),
       * otherEnd(the other end of this edge) and oldOwner(the owner of this edge which will become
       * an old owner after collapse operation)
       */
      if (this.edgesMetaLevels[edge.id()] != 0 && source != target) {
        var otherEnd = null;
        var oldOwner = null;
        if (source == childNode.id()) {
          otherEnd = target;
          oldOwner = source;
        }
        else if (target == childNode.id()) {
          otherEnd = source;
          oldOwner = target;
        }
        var info = {
          createdWhileBeingCollapsed: root.id(),
          otherEnd: otherEnd,
          oldOwner: oldOwner
        };
        if (this.collapsedMetaEdgesInfo[otherEnd] == null) {
          this.collapsedMetaEdgesInfo[otherEnd] = {};
        }
        if (this.collapsedMetaEdgesInfo[root.id()] == null) {
          this.collapsedMetaEdgesInfo[root.id()] = {};
        }
        //the information should be reachable by edge id and node id's
        this.collapsedMetaEdgesInfo[root.id()][otherEnd] = info;
        this.collapsedMetaEdgesInfo[otherEnd][root.id()] = info;
        this.collapsedMetaEdgesInfo[edge.id()] = info;
      }

      var removedEdge = edge.remove();
      //store the data of the original edge
      //to restore when the node is expanded
      if (root._private.data.edgesOfcollapsedChildren == null) {
        root._private.data.edgesOfcollapsedChildren = removedEdge;
      }
      else {
        root._private.data.edgesOfcollapsedChildren =
                root._private.data.edgesOfcollapsedChildren.union(removedEdge);
      }

      //Do not handle the inner edges
      if (!this.isOuterNode(sourceNode, root) && !this.isOuterNode(targetNode, root)) {
        continue;
      }

      //If the change source and/or target of the edge in the
      //case of they are equal to the id of the collapsed child
      if (source == childNode.id()) {
        source = root.id();
      }
      if (target == childNode.id()) {
        target = root.id();
      }

      //prepare the new edge by changing the older source and/or target
      newEdge.data.portsource = source;
      newEdge.data.porttarget = target;
      newEdge.data.source = source;
      newEdge.data.target = target;
      //remove the older edge and add the new one
      cy.add(newEdge);
      var newCyEdge = cy.edges()[cy.edges().length - 1];
      //If this edge has not meta class properties make it meta
      if (this.edgesMetaLevels[newCyEdge.id()] == 0) {
        newCyEdge.addClass("meta");
      }
      //Increase the meta level of this edge by 1
      this.edgesMetaLevels[newCyEdge.id()]++;
      newCyEdge.data("collapsedNodeBeforeBecamingMeta", childNode.id());
    }
  },
  /*
   * This method repairs the edges of the collapsed children of the given node
   * when the node is being expanded, the meta edges created while the node is
   * being collapsed are handled in this method
   */
  repairEdgesOfCollapsedChildren: function (node) { //*//
    var edgesOfcollapsedChildren = node._private.data.edgesOfcollapsedChildren;
    if (edgesOfcollapsedChildren == null) {
      return;
    }
    var collapsedMetaEdgeInfoOfNode = this.collapsedMetaEdgesInfo[node.id()];
    for (var i = 0; i < edgesOfcollapsedChildren.length; i++) {
      //Handle collapsed meta edge info if it is required
      if (collapsedMetaEdgeInfoOfNode != null &&
              this.collapsedMetaEdgesInfo[edgesOfcollapsedChildren[i]._private.data.id] != null) {
        var info = this.collapsedMetaEdgesInfo[edgesOfcollapsedChildren[i]._private.data.id];
        //If the meta edge is not created because of the reason that this node is collapsed
        //handle it by changing source or target of related edge datas
        if (info.createdWhileBeingCollapsed != node.id()) {
          if (edgesOfcollapsedChildren[i]._private.data.source == info.oldOwner) {
            edgesOfcollapsedChildren[i]._private.data.source = info.createdWhileBeingCollapsed;
            this.alterSourceOrTargetOfCollapsedEdge(info.createdWhileBeingCollapsed
                    , edgesOfcollapsedChildren[i]._private.data.id, "target");
          }
          else if (edgesOfcollapsedChildren[i]._private.data.target == info.oldOwner) {
            edgesOfcollapsedChildren[i]._private.data.target = info.createdWhileBeingCollapsed;
            this.alterSourceOrTargetOfCollapsedEdge(info.createdWhileBeingCollapsed
                    , edgesOfcollapsedChildren[i]._private.data.id, "source");
          }
        }
        //Delete the related collapsedMetaEdgesInfo's as they are handled
        delete this.collapsedMetaEdgesInfo[info.createdWhileBeingCollapsed][info.otherEnd];
        delete this.collapsedMetaEdgesInfo[info.otherEnd][info.createdWhileBeingCollapsed];
        delete this.collapsedMetaEdgesInfo[edgesOfcollapsedChildren[i]._private.data.id];
      }
      var oldEdge = cy.getElementById(edgesOfcollapsedChildren[i]._private.data.id);
      //If the edge is already in the graph remove it and decrease it's meta level
      if (oldEdge != null && oldEdge.length > 0) {
        this.edgesMetaLevels[edgesOfcollapsedChildren[i]._private.data.id]--;
        oldEdge.remove();
      }
    }

    /*edgesOfcollapsedChildren.restore();*/

    //Check for meta levels of edges and handle the changes
    this.edgesToRepair = this.edgesToRepair.union(edgesOfcollapsedChildren);

    node._private.data.edgesOfcollapsedChildren = null;
  },
  /*node is an outer node of root
   if root is not it's anchestor
   and it is not the root itself*/
  isOuterNode: function (node, root) {//*//
    var temp = node;
    while (temp != null) {
      if (temp == root) {
        return false;
      }
      temp = temp.parent()[0];
    }
    return true;
  }
};

module.exports = expandCollapseUtilities;
},{"./boundingBoxUtilities":1}],3:[function(_dereq_,module,exports){
var expandCollapseUtilities = _dereq_('./expandCollapseUtilities');

;
(function () {
  'use strict';

  // registers the extension on a cytoscape lib ref
  var register = function (cytoscape) {

    if (!cytoscape) {
      return;
    } // can't register if cytoscape unspecified

    var cy;
    var options = {
      layoutBy: null, // for rearrange after expand/collapse
      fisheye: true,
      animate: true,
      ready: function () {
      }
    };

    function setOptions(from) {
      var tempOpts = {};
      for (var key in options)
        tempOpts[key] = options[key];

      for (var key in from)
        if (tempOpts.hasOwnProperty(key))
          tempOpts[key] = from[key];
      return tempOpts;
    }

    var tappedBefore;
    var tappedTimeout;

    // cy.expandCollapse()
    cytoscape("core", "expandCollapse", function (opts) {
      cy = this;
      options = setOptions(opts);

      // test for expand-collapse
      cy.on('tap', function (event) {
        var tappedNow = event.cyTarget;
        if (tappedTimeout && tappedBefore) {
          clearTimeout(tappedTimeout);
        }
        if (tappedBefore === tappedNow) {
          tappedNow.trigger('doubleTap');
          tappedBefore = null;
        } else {
          tappedTimeout = setTimeout(function () {
            tappedBefore = null;
          }, 300);
          tappedBefore = tappedNow;
        }
      });

      cy.on("doubleTap", ':parent, [expanded-collapsed]', function (e) {
        if (e.cyTarget.data("expanded-collapsed") == "collapsed") {
          e.cyTarget.expand();
        } else {
          e.cyTarget.collapse();
        }
      });

      options.ready();

    });

    // Collection functions

    // eles.collapse(options)
    cytoscape('collection', 'collapse', function (opts) {
      var eles = this.collapsibleNodes();
      var tempOptions = setOptions(opts);

      return expandCollapseUtilities.collapseGivenNodes(eles, tempOptions);
    });

    // eles.collapseAll(options)
    cytoscape('collection', 'collapseAll', function (opts) {
      var eles = this.collapsibleNodes();
      var tempOptions = setOptions(opts);

      return eles.union(eles.descendants()).collapse(tempOptions);
    });

    // eles.expand(options)
    cytoscape('collection', 'expand', function (opts) {
      var eles = this.expandableNodes();
      var tempOptions = setOptions(opts);

      return expandCollapseUtilities.expandGivenNodes(eles, tempOptions);
    });

    // eles.expandAll(options)
    cytoscape('collection', 'expandAll', function (opts) {
      var eles = this.expandableNodes();
      var tempOptions = setOptions(opts);

      return expandCollapseUtilities.expandAllNodes(eles, tempOptions);
    });


    // Core functions

    // cy.collapseAll(options)
    cytoscape('core', 'collapseAll', function (opts) {
      var cy = this;
      var tempOptions = setOptions(opts);

      return cy.nodes().collapsibleNodes().collapseAll(tempOptions);
    });

    // cy.expandAll(options)
    cytoscape('core', 'expandAll', function (opts) {
      var cy = this;
      var tempOptions = setOptions(opts);

      return cy.nodes().expandableNodes().expandAll();
    });


    // Utility functions

    // ele.isCollapsible()
    cytoscape('collection', 'isExpandable', function () {
      var ele = this;

      return (ele.data("expanded-collapsed") === "collapsed");
    });

    // ele.isExpandable()
    cytoscape('collection', 'isCollapsible', function () {
      var ele = this;
      return !ele.isExpandable() && ele.isParent();
    });

    // eles.collapsed()
    cytoscape('collection', 'collapsibleNodes', function () {
      var eles = this;

      return eles.filter(function (i, ele) {
        return ele.isCollapsible();
      });
    });

    // eles.expanded()
    cytoscape('collection', 'expandableNodes', function () {
      var eles = this;

      return eles.filter(function (i, ele) {
        return ele.isExpandable();
      });
    });
  };

  if (typeof module !== 'undefined' && module.exports) { // expose as a commonjs module
    module.exports = register;
  }

  if (typeof define !== 'undefined' && define.amd) { // expose as an amd/requirejs module
    define('cytoscape-expand-collapse', function () {
      return register;
    });
  }

  if (typeof cytoscape !== 'undefined') { // expose to global cytoscape (i.e. window.cytoscape)
    register(cytoscape);
  }

})();

},{"./expandCollapseUtilities":2}]},{},[3])(3)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvYm91bmRpbmdCb3hVdGlsaXRpZXMuanMiLCJzcmMvZXhwYW5kQ29sbGFwc2VVdGlsaXRpZXMuanMiLCJzcmMvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeHdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwidmFyIGJvdW5kaW5nQm94VXRpbGl0aWVzID0ge1xuICBlcXVhbEJvdW5kaW5nQm94ZXM6IGZ1bmN0aW9uKGJiMSwgYmIyKXtcbiAgICAgIHJldHVybiBiYjEueDEgPT0gYmIyLngxICYmIGJiMS54MiA9PSBiYjIueDIgJiYgYmIxLnkxID09IGJiMi55MSAmJiBiYjEueTIgPT0gYmIyLnkyO1xuICB9LFxuICBnZXRVbmlvbjogZnVuY3Rpb24oYmIxLCBiYjIpe1xuICAgICAgdmFyIHVuaW9uID0ge1xuICAgICAgeDE6IE1hdGgubWluKGJiMS54MSwgYmIyLngxKSxcbiAgICAgIHgyOiBNYXRoLm1heChiYjEueDIsIGJiMi54MiksXG4gICAgICB5MTogTWF0aC5taW4oYmIxLnkxLCBiYjIueTEpLFxuICAgICAgeTI6IE1hdGgubWF4KGJiMS55MiwgYmIyLnkyKSxcbiAgICB9O1xuXG4gICAgdW5pb24udyA9IHVuaW9uLngyIC0gdW5pb24ueDE7XG4gICAgdW5pb24uaCA9IHVuaW9uLnkyIC0gdW5pb24ueTE7XG5cbiAgICByZXR1cm4gdW5pb247XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYm91bmRpbmdCb3hVdGlsaXRpZXM7IiwidmFyIGJvdW5kaW5nQm94VXRpbGl0aWVzID0gcmVxdWlyZSgnLi9ib3VuZGluZ0JveFV0aWxpdGllcycpO1xuXG4vLyBFeHBhbmQgY29sbGFwc2UgdXRpbGl0aWVzXG52YXIgZXhwYW5kQ29sbGFwc2VVdGlsaXRpZXMgPSB7XG4gIGVkZ2VzVG9SZXBhaXI6IG51bGwsXG4gIC8vdGhlIG51bWJlciBvZiBub2RlcyBtb3ZpbmcgYW5pbWF0ZWRseSBhZnRlciBleHBhbmQgb3BlcmF0aW9uXG4gIGFuaW1hdGVkbHlNb3ZpbmdOb2RlQ291bnQ6IDAsXG4gIC8vVGhpcyBpcyBhIG1hcCB3aGljaCBrZWVwcyB0aGUgaW5mb3JtYXRpb24gb2YgY29sbGFwc2VkIG1ldGEgZWRnZXMgdG8gaGFuZGxlIHRoZW0gY29ycmVjdGx5XG4gIGNvbGxhcHNlZE1ldGFFZGdlc0luZm86IHt9LFxuICAvL1RoaXMgbWFwIGtlZXBzIHRyYWNrIG9mIHRoZSBtZXRhIGxldmVscyBvZiBlZGdlcyBieSB0aGVpciBpZCdzXG4gIGVkZ2VzTWV0YUxldmVsczoge30sXG4gIG1vdmVOb2RlczogZnVuY3Rpb24gKHBvc2l0aW9uRGlmZiwgbm9kZXMsIG5vdENhbGNUb3BNb3N0Tm9kZXMpIHtcbiAgICB2YXIgdG9wTW9zdE5vZGVzID0gbm90Q2FsY1RvcE1vc3ROb2RlcyA/IG5vZGVzIDogdGhpcy5nZXRUb3BNb3N0Tm9kZXMobm9kZXMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9wTW9zdE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbm9kZSA9IHRvcE1vc3ROb2Rlc1tpXTtcbiAgICAgIHZhciBvbGRYID0gbm9kZS5wb3NpdGlvbihcInhcIik7XG4gICAgICB2YXIgb2xkWSA9IG5vZGUucG9zaXRpb24oXCJ5XCIpO1xuICAgICAgbm9kZS5wb3NpdGlvbih7XG4gICAgICAgIHg6IG9sZFggKyBwb3NpdGlvbkRpZmYueCxcbiAgICAgICAgeTogb2xkWSArIHBvc2l0aW9uRGlmZi55XG4gICAgICB9KTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4oKTtcbiAgICAgIHRoaXMubW92ZU5vZGVzKHBvc2l0aW9uRGlmZiwgY2hpbGRyZW4sIHRydWUpO1xuICAgIH1cbiAgfSxcbiAgZ2V0VG9wTW9zdE5vZGVzOiBmdW5jdGlvbiAobm9kZXMpIHsvLyovL1xuICAgIHZhciBub2Rlc01hcCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGVzTWFwW25vZGVzW2ldLmlkKCldID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHJvb3RzID0gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChpLCBlbGUpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBlbGUucGFyZW50KClbMF07XG4gICAgICB3aGlsZSAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVzTWFwW3BhcmVudC5pZCgpXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50KClbMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIHJldHVybiByb290cztcbiAgfSxcbiAgcmVhcnJhbmdlOiBmdW5jdGlvbiAobGF5b3V0QnkpIHsvLyovL1xuICAgIGlmICh0eXBlb2YgbGF5b3V0QnkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgbGF5b3V0QnkoKTtcbiAgICB9IGVsc2UgaWYgKGxheW91dEJ5ICE9IG51bGwpIHtcbiAgICAgIGN5LmxheW91dChsYXlvdXRCeSk7XG4gICAgfVxuICB9LFxuICAvL1RoaXMgbWV0aG9kIGNoYW5nZXMgc291cmNlIG9yIHRhcmdldCBpZCBvZiB0aGUgY29sbGFwc2VkIGVkZ2UgZGF0YSBrZXB0IGluIHRoZSBkYXRhIG9mIHRoZSBub2RlXG4gIC8vd2l0aCBpZCBvZiBjcmVhdGVkV2hpbGVCZWluZ0NvbGxhcHNlZFxuICBhbHRlclNvdXJjZU9yVGFyZ2V0T2ZDb2xsYXBzZWRFZGdlOiBmdW5jdGlvbiAoY3JlYXRlZFdoaWxlQmVpbmdDb2xsYXBzZWQsIGVkZ2VJZCwgc291cmNlT3JUYXJnZXQpIHsvLyovL1xuICAgIHZhciBub2RlID0gY3kuZ2V0RWxlbWVudEJ5SWQoY3JlYXRlZFdoaWxlQmVpbmdDb2xsYXBzZWQpWzBdO1xuICAgIHZhciBlZGdlc09mY29sbGFwc2VkQ2hpbGRyZW4gPSBub2RlLl9wcml2YXRlLmRhdGEuZWRnZXNPZmNvbGxhcHNlZENoaWxkcmVuO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXNPZmNvbGxhcHNlZENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY29sbGFwc2VkRWRnZSA9IGVkZ2VzT2Zjb2xsYXBzZWRDaGlsZHJlbltpXTtcbiAgICAgIGlmIChjb2xsYXBzZWRFZGdlLl9wcml2YXRlLmRhdGEuaWQgPT0gZWRnZUlkKSB7XG4gICAgICAgIGNvbGxhcHNlZEVkZ2UuX3ByaXZhdGUuZGF0YVtzb3VyY2VPclRhcmdldF0gPSBjb2xsYXBzZWRFZGdlLl9wcml2YXRlLmRhdGEuY29sbGFwc2VkTm9kZUJlZm9yZUJlY2FtaW5nTWV0YTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvL0EgZnVudGlvbiBiYXNpY2x5IGV4cGFuZGluZyBhIG5vZGUgaXQgaXMgdG8gYmUgY2FsbGVkIHdoZW4gYSBub2RlIGlzIGV4cGFuZGVkIGFueXdheVxuICBleHBhbmROb2RlQmFzZUZ1bmN0aW9uOiBmdW5jdGlvbiAobm9kZSwgdHJpZ2dlckxheW91dCwgc2luZ2xlLCBsYXlvdXRCeSkgey8vKi8vXG4gICAgLy9jaGVjayBob3cgdGhlIHBvc2l0aW9uIG9mIHRoZSBub2RlIGlzIGNoYW5nZWRcbiAgICB2YXIgcG9zaXRpb25EaWZmID0ge1xuICAgICAgeDogbm9kZS5wb3NpdGlvbigneCcpIC0gbm9kZS5kYXRhKCdwb3NpdGlvbi1iZWZvcmUtY29sbGFwc2UnKS54LFxuICAgICAgeTogbm9kZS5wb3NpdGlvbigneScpIC0gbm9kZS5kYXRhKCdwb3NpdGlvbi1iZWZvcmUtY29sbGFwc2UnKS55XG4gICAgfTtcblxuICAgIG5vZGUucmVtb3ZlRGF0YShcImluZm9MYWJlbFwiKTtcbiAgICBub2RlLmRhdGEoJ2V4cGFuZGVkLWNvbGxhcHNlZCcsICdleHBhbmRlZCcpO1xuICAgIG5vZGUuX3ByaXZhdGUuZGF0YS5jb2xsYXBzZWRDaGlsZHJlbi5ub2RlcygpLnJlc3RvcmUoKTtcbiAgICB0aGlzLnJlcGFpckVkZ2VzT2ZDb2xsYXBzZWRDaGlsZHJlbihub2RlKTtcbiAgICBub2RlLl9wcml2YXRlLmRhdGEuY29sbGFwc2VkQ2hpbGRyZW4gPSBudWxsO1xuXG4gICAgY3kubm9kZXMoKS51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuXG4gICAgLy9Eb24ndCBzaG93IGNoaWxkcmVuIGluZm8gd2hlbiB0aGUgY29tcGxleCBub2RlIGlzIGV4cGFuZGVkXG4gICAgaWYgKG5vZGUuX3ByaXZhdGUuZGF0YS5zYmduY2xhc3MgPT0gXCJjb21wbGV4XCIpIHtcbiAgICAgIG5vZGUucmVtb3ZlU3R5bGUoJ2NvbnRlbnQnKTtcbiAgICB9XG5cbiAgICB0aGlzLm1vdmVOb2Rlcyhwb3NpdGlvbkRpZmYsIG5vZGUuY2hpbGRyZW4oKSk7XG4gICAgbm9kZS5yZW1vdmVEYXRhKCdwb3NpdGlvbi1iZWZvcmUtY29sbGFwc2UnKTtcblxuICAgIGlmIChzaW5nbGUpXG4gICAgICB0aGlzLmVuZE9wZXJhdGlvbigpO1xuICAgIC8vIHJlZnJlc2hQYWRkaW5ncygpO1xuICAgIGlmICh0cmlnZ2VyTGF5b3V0KSB7IC8vKi8qLyphc2RzYWRkYVxuICAgICAgdGhpcy5yZWFycmFuZ2UobGF5b3V0QnkpO1xuXG4gICAgfVxuICB9LFxuICBzaW1wbGVDb2xsYXBzZUdpdmVuTm9kZXM6IGZ1bmN0aW9uIChub2Rlcykgey8vKi8vXG4gICAgbm9kZXMuZGF0YShcImNvbGxhcHNlXCIsIHRydWUpO1xuICAgIHZhciByb290cyA9IHRoaXMuZ2V0VG9wTW9zdE5vZGVzKG5vZGVzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcm9vdCA9IHJvb3RzW2ldO1xuICAgICAgdGhpcy5jb2xsYXBzZUJvdHRvbVVwKHJvb3QpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXM7XG4gIH0sXG4gIHNpbXBsZUV4cGFuZEdpdmVuTm9kZXM6IGZ1bmN0aW9uIChub2RlcywgYXBwbHlGaXNoRXllVmlld1RvRWFjaE5vZGUpIHsvLyovL1xuICAgIG5vZGVzLmRhdGEoXCJleHBhbmRcIiwgdHJ1ZSk7XG4gICAgdmFyIHJvb3RzID0gdGhpcy5nZXRUb3BNb3N0Tm9kZXMobm9kZXMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByb290ID0gcm9vdHNbaV07XG4gICAgICB0aGlzLmV4cGFuZFRvcERvd24ocm9vdCwgYXBwbHlGaXNoRXllVmlld1RvRWFjaE5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXM7XG4gIH0sXG4gIHNpbXBsZUV4cGFuZEFsbE5vZGVzOiBmdW5jdGlvbiAobm9kZXMsIGFwcGx5RmlzaEV5ZVZpZXdUb0VhY2hOb2RlKSB7Ly8qLy9cbiAgICBpZiAobm9kZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9kZXMgPSBjeS5ub2RlcygpO1xuICAgIH1cbiAgICB2YXIgb3JwaGFucztcbiAgICBjb25zb2xlLmxvZyh0aGlzLmdldFRvcE1vc3ROb2Rlcyhub2RlcykubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gZS5pZCgpO1xuICAgIH0pLCBub2Rlcy5vcnBoYW5zKCkubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gZS5pZCgpO1xuICAgIH0pKTtcbiAgICBvcnBoYW5zID0gdGhpcy5nZXRUb3BNb3N0Tm9kZXMobm9kZXMpO1xuICAgIHZhciBleHBhbmRTdGFjayA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JwaGFucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJvb3QgPSBvcnBoYW5zW2ldO1xuICAgICAgdGhpcy5leHBhbmRBbGxUb3BEb3duKHJvb3QsIGV4cGFuZFN0YWNrLCBhcHBseUZpc2hFeWVWaWV3VG9FYWNoTm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBleHBhbmRTdGFjaztcbiAgfSxcbiAgYmVnaW5PcGVyYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVkZ2VzVG9SZXBhaXIgPSBjeS5jb2xsZWN0aW9uKCk7XG4gIH0sXG4gIGVuZE9wZXJhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZWRnZXNUb1JlcGFpci5yZXN0b3JlKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVkZ2VzVG9SZXBhaXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlZGdlID0gdGhpcy5lZGdlc1RvUmVwYWlyW2ldO1xuICAgICAgaWYgKHRoaXMuZWRnZXNNZXRhTGV2ZWxzW2VkZ2UuaWQoKV0gPT0gbnVsbCB8fCB0aGlzLmVkZ2VzTWV0YUxldmVsc1tlZGdlLmlkKCldID09IDApIHtcbiAgICAgICAgZWRnZS5yZW1vdmVDbGFzcyhcIm1ldGFcIik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZWRnZS5hZGRDbGFzcyhcIm1ldGFcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZWRnZXNUb1JlcGFpciA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgfSxcbiAgZXhwYW5kQWxsTm9kZXM6IGZ1bmN0aW9uIChub2Rlcywgb3B0aW9ucykgey8vKi8vXG4gICAgdGhpcy5iZWdpbk9wZXJhdGlvbigpO1xuICAgIGN5LnRyaWdnZXIoXCJiZWZvcmVFeHBhbmRcIiwgW25vZGVzLCBvcHRpb25zXSk7XG4gICAgdmFyIGV4cGFuZGVkU3RhY2sgPSB0aGlzLnNpbXBsZUV4cGFuZEFsbE5vZGVzKG5vZGVzLCBvcHRpb25zLmZpc2hleWUpO1xuICAgIGN5LnRyaWdnZXIoXCJhZnRlckV4cGFuZFwiLCBbbm9kZXMsIG9wdGlvbnNdKTtcblxuICAgIHRoaXMuZW5kT3BlcmF0aW9uKCk7XG5cbiAgICB0aGlzLnJlYXJyYW5nZShvcHRpb25zLmxheW91dEJ5KTtcblxuICAgIC8qXG4gICAgICogcmV0dXJuIHRoZSBub2RlcyB0byB1bmRvIHRoZSBvcGVyYXRpb25cbiAgICAgKi9cbiAgICByZXR1cm4gZXhwYW5kZWRTdGFjaztcbiAgfSxcbiAgZXhwYW5kQWxsVG9wRG93bjogZnVuY3Rpb24gKHJvb3QsIGV4cGFuZFN0YWNrLCBhcHBseUZpc2hFeWVWaWV3VG9FYWNoTm9kZSkgey8vKi8vXG4gICAgaWYgKHJvb3QuX3ByaXZhdGUuZGF0YS5jb2xsYXBzZWRDaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICBleHBhbmRTdGFjay5wdXNoKHJvb3QpO1xuICAgICAgdGhpcy5zaW1wbGVFeHBhbmROb2RlKHJvb3QsIGFwcGx5RmlzaEV5ZVZpZXdUb0VhY2hOb2RlKTtcbiAgICB9XG4gICAgdmFyIGNoaWxkcmVuID0gcm9vdC5jaGlsZHJlbigpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBub2RlID0gY2hpbGRyZW5baV07XG4gICAgICB0aGlzLmV4cGFuZEFsbFRvcERvd24obm9kZSwgZXhwYW5kU3RhY2ssIGFwcGx5RmlzaEV5ZVZpZXdUb0VhY2hOb2RlKTtcbiAgICB9XG4gIH0sXG4gIC8vRXhwYW5kIHRoZSBnaXZlbiBub2RlcyBwZXJmb3JtIGluY3JlbWVudGFsIGxheW91dCBhZnRlciBleHBhbmRhdGlvblxuICBleHBhbmRHaXZlbk5vZGVzOiBmdW5jdGlvbiAobm9kZXMsIG9wdGlvbnMpIHsvLyovL1xuICAgIHRoaXMuYmVnaW5PcGVyYXRpb24oKTtcbiAgICBjeS50cmlnZ2VyKFwiYmVmb3JlRXhwYW5kXCIsIFtub2Rlcywgb3B0aW9uc10pO1xuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuZXhwYW5kTm9kZShub2Rlc1swXSwgb3B0aW9ucy5maXNoZXllLCBvcHRpb25zLmFuaW1hdGUsIG9wdGlvbnMubGF5b3V0QnkpO1xuICAgICAgY3kudHJpZ2dlcihcImFmdGVyRXhwYW5kXCIsIFtub2Rlcywgb3B0aW9uc10pO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2ltcGxlRXhwYW5kR2l2ZW5Ob2Rlcyhub2Rlcywgb3B0aW9ucy5maXNoZXllKTtcbiAgICAgIHRoaXMuZW5kT3BlcmF0aW9uKCk7XG4gICAgICBjeS50cmlnZ2VyKFwiYWZ0ZXJFeHBhbmRcIiwgW25vZGVzLCBvcHRpb25zXSk7XG5cbiAgICAgIHRoaXMucmVhcnJhbmdlKG9wdGlvbnMubGF5b3V0QnkpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogcmV0dXJuIHRoZSBub2RlcyB0byB1bmRvIHRoZSBvcGVyYXRpb25cbiAgICAgKi9cbiAgICByZXR1cm4gbm9kZXM7XG4gIH0sXG4gIC8vY29sbGFwc2UgdGhlIGdpdmVuIG5vZGVzIHRoZW4gbWFrZSBpbmNyZW1lbnRhbCBsYXlvdXRcbiAgY29sbGFwc2VHaXZlbk5vZGVzOiBmdW5jdGlvbiAobm9kZXMsIG9wdGlvbnMpIHsvLyovL1xuICAgIHRoaXMuYmVnaW5PcGVyYXRpb24oKTtcbiAgICBjeS50cmlnZ2VyKFwiYmVmb3JlQ29sbGFwc2VcIiwgW25vZGVzLCBvcHRpb25zXSk7XG4gICAgdGhpcy5zaW1wbGVDb2xsYXBzZUdpdmVuTm9kZXMobm9kZXMsIG9wdGlvbnMpO1xuICAgIGN5LnRyaWdnZXIoXCJiZWZvcmVDb2xsYXBzZVwiLCBbbm9kZXMsIG9wdGlvbnNdKTtcblxuICAgIHRoaXMuZW5kT3BlcmF0aW9uKCk7XG4gICAgdGhpcy5yZWFycmFuZ2Uob3B0aW9ucy5sYXlvdXRCeSk7XG5cbiAgICAvKlxuICAgICAqIHJldHVybiB0aGUgbm9kZXMgdG8gdW5kbyB0aGUgb3BlcmF0aW9uXG4gICAgICovXG4gICAgcmV0dXJuIG5vZGVzO1xuICB9LFxuICAvL2NvbGxhcHNlIHRoZSBub2RlcyBpbiBib3R0b20gdXAgb3JkZXIgc3RhcnRpbmcgZnJvbSB0aGUgcm9vdFxuICBjb2xsYXBzZUJvdHRvbVVwOiBmdW5jdGlvbiAocm9vdCkgey8vKi8vXG4gICAgdmFyIGNoaWxkcmVuID0gcm9vdC5jaGlsZHJlbigpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBub2RlID0gY2hpbGRyZW5baV07XG4gICAgICB0aGlzLmNvbGxhcHNlQm90dG9tVXAobm9kZSk7XG4gICAgfVxuICAgIC8vSWYgdGhlIHJvb3QgaXMgYSBjb21wb3VuZCBub2RlIHRvIGJlIGNvbGxhcHNlZCB0aGVuIGNvbGxhcHNlIGl0XG4gICAgaWYgKHJvb3QuZGF0YShcImNvbGxhcHNlXCIpICYmIHJvb3QuY2hpbGRyZW4oKS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnNpbXBsZUNvbGxhcHNlTm9kZShyb290KTtcbiAgICAgIHJvb3QucmVtb3ZlRGF0YShcImNvbGxhcHNlXCIpO1xuICAgIH1cbiAgfSxcbiAgLy9leHBhbmQgdGhlIG5vZGVzIGluIHRvcCBkb3duIG9yZGVyIHN0YXJ0aW5nIGZyb20gdGhlIHJvb3RcbiAgZXhwYW5kVG9wRG93bjogZnVuY3Rpb24gKHJvb3QsIGFwcGx5RmlzaEV5ZVZpZXdUb0VhY2hOb2RlKSB7Ly8qLy9cbiAgICBpZiAocm9vdC5kYXRhKFwiZXhwYW5kXCIpICYmIHJvb3QuX3ByaXZhdGUuZGF0YS5jb2xsYXBzZWRDaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICB0aGlzLnNpbXBsZUV4cGFuZE5vZGUocm9vdCwgYXBwbHlGaXNoRXllVmlld1RvRWFjaE5vZGUpO1xuICAgICAgcm9vdC5yZW1vdmVEYXRhKFwiZXhwYW5kXCIpO1xuICAgIH1cbiAgICB2YXIgY2hpbGRyZW4gPSByb290LmNoaWxkcmVuKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBjaGlsZHJlbltpXTtcbiAgICAgIHRoaXMuZXhwYW5kVG9wRG93bihub2RlKTtcbiAgICB9XG4gIH0sXG4gIGV4cGFuZE5vZGU6IGZ1bmN0aW9uIChub2RlLCBmaXNoZXllLCBhbmltYXRlLCBsYXlvdXRCeSkge1xuICAgIGlmIChub2RlLl9wcml2YXRlLmRhdGEuY29sbGFwc2VkQ2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgdGhpcy5zaW1wbGVFeHBhbmROb2RlKG5vZGUsIGZpc2hleWUsIHRydWUsIGFuaW1hdGUsIGxheW91dEJ5KTtcblxuICAgICAgLypcbiAgICAgICAqIHJldHVybiB0aGUgbm9kZSB0byB1bmRvIHRoZSBvcGVyYXRpb25cbiAgICAgICAqL1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9LFxuICBjb252ZXJ0VG9Nb2RlbFBvc2l0aW9uOiBmdW5jdGlvbiAocmVuZGVyZWRQb3NpdGlvbikge1xuICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcblxuICAgIHZhciB4ID0gKHJlbmRlcmVkUG9zaXRpb24ueCAtIHBhbi54KSAvIHpvb207XG4gICAgdmFyIHkgPSAocmVuZGVyZWRQb3NpdGlvbi55IC0gcGFuLnkpIC8gem9vbTtcblxuICAgIHJldHVybiB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH07XG4gIH0sXG4gIC8qXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGV4cGFuZHMgdGhlIGdpdmVuIG5vZGVcbiAgICogd2l0aG91dCBtYWtpbmcgaW5jcmVtZW50YWwgbGF5b3V0XG4gICAqIGFmdGVyIGV4cGFuZCBvcGVyYXRpb24gaXQgd2lsbCBiZSBzaW1wbHlcbiAgICogdXNlZCB0byB1bmRvIHRoZSBjb2xsYXBzZSBvcGVyYXRpb25cbiAgICovXG4gIHNpbXBsZUV4cGFuZE5vZGU6IGZ1bmN0aW9uIChub2RlLCBhcHBseUZpc2hFeWVWaWV3VG9FYWNoTm9kZSwgc2luZ2xlTm90U2ltcGxlLCBhbmltYXRlLCBsYXlvdXRCeSkgey8vKi8vXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIGNvbW1vbkV4cGFuZE9wZXJhdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBhcHBseUZpc2hFeWVWaWV3VG9FYWNoTm9kZSwgc2luZ2xlTm90U2ltcGxlLCBhbmltYXRlLCBsYXlvdXRCeSkge1xuICAgICAgaWYgKGFwcGx5RmlzaEV5ZVZpZXdUb0VhY2hOb2RlKSB7XG5cbiAgICAgICAgbm9kZS5kYXRhKCd3aWR0aC1iZWZvcmUtZmlzaGV5ZScsIG5vZGUuZGF0YSgnc2l6ZS1iZWZvcmUtY29sbGFwc2UnKS53KTtcbiAgICAgICAgbm9kZS5kYXRhKCdoZWlnaHQtYmVmb3JlLWZpc2hleWUnLCBub2RlLmRhdGEoJ3NpemUtYmVmb3JlLWNvbGxhcHNlJykuaCk7XG5cbiAgICAgICAgc2VsZi5maXNoRXllVmlld0V4cGFuZEdpdmVuTm9kZShub2RlLCBzaW5nbGVOb3RTaW1wbGUsIG5vZGUsIGFuaW1hdGUsIGxheW91dEJ5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzaW5nbGVOb3RTaW1wbGUgfHwgIWFwcGx5RmlzaEV5ZVZpZXdUb0VhY2hOb2RlIHx8ICFhbmltYXRlKSB7XG4gICAgICAgIHNlbGYuZXhwYW5kTm9kZUJhc2VGdW5jdGlvbihub2RlLCBzaW5nbGVOb3RTaW1wbGUsIHNpbmdsZU5vdFNpbXBsZSwgbGF5b3V0QnkpOyAvLyoqKioqXG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChub2RlLl9wcml2YXRlLmRhdGEuY29sbGFwc2VkQ2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgdGhpcy5zdG9yZVdpZHRoSGVpZ2h0KG5vZGUpO1xuICAgICAgaWYgKGFwcGx5RmlzaEV5ZVZpZXdUb0VhY2hOb2RlICYmIHNpbmdsZU5vdFNpbXBsZSkge1xuICAgICAgICB2YXIgdG9wTGVmdFBvc2l0aW9uID0gdGhpcy5jb252ZXJ0VG9Nb2RlbFBvc2l0aW9uKHt4OiAwLCB5OiAwfSk7XG4gICAgICAgIHZhciBib3R0b21SaWdodFBvc2l0aW9uID0gdGhpcy5jb252ZXJ0VG9Nb2RlbFBvc2l0aW9uKHt4OiBjeS53aWR0aCgpLCB5OiBjeS5oZWlnaHQoKX0pO1xuICAgICAgICB2YXIgcGFkZGluZyA9IDgwO1xuICAgICAgICB2YXIgYmIgPSB7XG4gICAgICAgICAgeDE6IHRvcExlZnRQb3NpdGlvbi54LFxuICAgICAgICAgIHgyOiBib3R0b21SaWdodFBvc2l0aW9uLngsXG4gICAgICAgICAgeTE6IHRvcExlZnRQb3NpdGlvbi55LFxuICAgICAgICAgIHkyOiBib3R0b21SaWdodFBvc2l0aW9uLnlcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbm9kZUJCID0ge1xuICAgICAgICAgIHgxOiBub2RlLnBvc2l0aW9uKCd4JykgLSBub2RlLmRhdGEoJ3NpemUtYmVmb3JlLWNvbGxhcHNlJykudyAvIDIgLSBwYWRkaW5nLFxuICAgICAgICAgIHgyOiBub2RlLnBvc2l0aW9uKCd4JykgKyBub2RlLmRhdGEoJ3NpemUtYmVmb3JlLWNvbGxhcHNlJykudyAvIDIgKyBwYWRkaW5nLFxuICAgICAgICAgIHkxOiBub2RlLnBvc2l0aW9uKCd5JykgLSBub2RlLmRhdGEoJ3NpemUtYmVmb3JlLWNvbGxhcHNlJykuaCAvIDIgLSBwYWRkaW5nLFxuICAgICAgICAgIHkyOiBub2RlLnBvc2l0aW9uKCd5JykgKyBub2RlLmRhdGEoJ3NpemUtYmVmb3JlLWNvbGxhcHNlJykuaCAvIDIgKyBwYWRkaW5nXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHVuaW9uQkIgPSBib3VuZGluZ0JveFV0aWxpdGllcy5nZXRVbmlvbihub2RlQkIsIGJiKTtcbiAgICAgICAgdmFyIGFuaW1hdGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghYm91bmRpbmdCb3hVdGlsaXRpZXMuZXF1YWxCb3VuZGluZ0JveGVzKHVuaW9uQkIsIGJiKSkge1xuICAgICAgICAgIHZhciB2aWV3UG9ydCA9IGN5LmdldEZpdFZpZXdwb3J0KHVuaW9uQkIsIDEwKTtcbiAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgYW5pbWF0aW5nID0gYW5pbWF0ZTtcbiAgICAgICAgICBpZiAoYW5pbWF0ZSkge1xuICAgICAgICAgICAgY3kuYW5pbWF0ZSh7XG4gICAgICAgICAgICAgIHBhbjogdmlld1BvcnQucGFuLFxuICAgICAgICAgICAgICB6b29tOiB2aWV3UG9ydC56b29tLFxuICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbW1vbkV4cGFuZE9wZXJhdGlvbihub2RlLCBhcHBseUZpc2hFeWVWaWV3VG9FYWNoTm9kZSwgc2luZ2xlTm90U2ltcGxlLCBhbmltYXRlLCBsYXlvdXRCeSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgZHVyYXRpb246IDEwMDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJhbmltYXRlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiem9vbVwiKTtcbiAgICAgICAgICAgIGN5Lnpvb20odmlld1BvcnQuem9vbSk7XG4gICAgICAgICAgICBjeS5wYW4odmlld1BvcnQucGFuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhbmltYXRpbmcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcImFuaW1hdGluZ1wiKTtcbiAgICAgICAgICBjb21tb25FeHBhbmRPcGVyYXRpb24obm9kZSwgYXBwbHlGaXNoRXllVmlld1RvRWFjaE5vZGUsIHNpbmdsZU5vdFNpbXBsZSwgYW5pbWF0ZSwgbGF5b3V0QnkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29tbW9uRXhwYW5kT3BlcmF0aW9uKG5vZGUsIGFwcGx5RmlzaEV5ZVZpZXdUb0VhY2hOb2RlLCBzaW5nbGVOb3RTaW1wbGUsIGFuaW1hdGUsIGxheW91dEJ5KTtcbiAgICAgIH1cblxuICAgICAgLy9yZXR1cm4gdGhlIG5vZGUgdG8gdW5kbyB0aGUgb3BlcmF0aW9uXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH0sXG4gIC8vY29sbGFwc2UgdGhlIGdpdmVuIG5vZGUgd2l0aG91dCBtYWtpbmcgaW5jcmVtZW50YWwgbGF5b3V0XG4gIHNpbXBsZUNvbGxhcHNlTm9kZTogZnVuY3Rpb24gKG5vZGUpIHsvLyovL1xuICAgIGlmIChub2RlLl9wcml2YXRlLmRhdGEuY29sbGFwc2VkQ2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgbm9kZS5kYXRhKCdwb3NpdGlvbi1iZWZvcmUtY29sbGFwc2UnLCB7XG4gICAgICAgIHg6IG5vZGUucG9zaXRpb24oKS54LFxuICAgICAgICB5OiBub2RlLnBvc2l0aW9uKCkueVxuICAgICAgfSk7XG5cbiAgICAgIG5vZGUuZGF0YSgnc2l6ZS1iZWZvcmUtY29sbGFwc2UnLCB7XG4gICAgICAgIHc6IG5vZGUub3V0ZXJXaWR0aCgpLFxuICAgICAgICBoOiBub2RlLm91dGVySGVpZ2h0KClcbiAgICAgIH0pO1xuXG4gICAgICBub2RlLmNoaWxkcmVuKCkudW5zZWxlY3QoKTtcbiAgICAgIG5vZGUuY2hpbGRyZW4oKS5jb25uZWN0ZWRFZGdlcygpLnVuc2VsZWN0KCk7XG5cbiAgICAgIG5vZGUuZGF0YSgnZXhwYW5kZWQtY29sbGFwc2VkJywgJ2NvbGxhcHNlZCcpO1xuXG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuKCk7XG5cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgdGhpcy5iYXJyb3dFZGdlc09mY29sbGFwc2VkQ2hpbGRyZW4obm9kZSwgY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbW92ZUNoaWxkcmVuKG5vZGUsIG5vZGUpO1xuICAgICAgLy8gcmVmcmVzaFBhZGRpbmdzKCk7XG5cbiAgICAgIGlmIChub2RlLl9wcml2YXRlLmRhdGEuc2JnbmNsYXNzID09IFwiY29tcGxleFwiKSB7XG4gICAgICAgIG5vZGUuYWRkQ2xhc3MoJ2NoYW5nZUNvbnRlbnQnKTtcbiAgICAgIH1cblxuICAgICAgbm9kZS5wb3NpdGlvbihub2RlLmRhdGEoJ3Bvc2l0aW9uLWJlZm9yZS1jb2xsYXBzZScpKTtcblxuICAgICAgLy9yZXR1cm4gdGhlIG5vZGUgdG8gdW5kbyB0aGUgb3BlcmF0aW9uXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH0sXG4gIHN0b3JlV2lkdGhIZWlnaHQ6IGZ1bmN0aW9uIChub2RlKSB7Ly8qLy9cbiAgICBpZiAobm9kZSAhPSBudWxsKSB7XG4gICAgICBub2RlLmRhdGEoJ3gtYmVmb3JlLWZpc2hleWUnLCB0aGlzLnhQb3NpdGlvbkluUGFyZW50KG5vZGUpKTtcbiAgICAgIG5vZGUuZGF0YSgneS1iZWZvcmUtZmlzaGV5ZScsIHRoaXMueVBvc2l0aW9uSW5QYXJlbnQobm9kZSkpO1xuICAgICAgbm9kZS5kYXRhKCd3aWR0aC1iZWZvcmUtZmlzaGV5ZScsIG5vZGUub3V0ZXJXaWR0aCgpKTtcbiAgICAgIG5vZGUuZGF0YSgnaGVpZ2h0LWJlZm9yZS1maXNoZXllJywgbm9kZS5vdXRlckhlaWdodCgpKTtcblxuICAgICAgaWYgKG5vZGUucGFyZW50KClbMF0gIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnN0b3JlV2lkdGhIZWlnaHQobm9kZS5wYXJlbnQoKVswXSk7XG4gICAgICB9XG4gICAgfVxuXG4gIH0sXG4gIGZpc2hFeWVWaWV3RXhwYW5kR2l2ZW5Ob2RlOiBmdW5jdGlvbiAobm9kZSwgc2luZ2xlTm90U2ltcGxlLCBub2RlVG9FeHBhbmQsIGFuaW1hdGUsIGxheW91dEJ5KSB7Ly8qLy9cbiAgICB2YXIgc2libGluZ3MgPSB0aGlzLmdldFNpYmxpbmdzKG5vZGUpO1xuXG4gICAgdmFyIHhfYSA9IHRoaXMueFBvc2l0aW9uSW5QYXJlbnQobm9kZSk7XG4gICAgdmFyIHlfYSA9IHRoaXMueVBvc2l0aW9uSW5QYXJlbnQobm9kZSk7XG5cbiAgICB2YXIgZF94X2xlZnQgPSBNYXRoLmFicygobm9kZS5kYXRhKCd3aWR0aC1iZWZvcmUtZmlzaGV5ZScpIC0gbm9kZS5vdXRlcldpZHRoKCkpIC8gMik7XG4gICAgdmFyIGRfeF9yaWdodCA9IE1hdGguYWJzKChub2RlLmRhdGEoJ3dpZHRoLWJlZm9yZS1maXNoZXllJykgLSBub2RlLm91dGVyV2lkdGgoKSkgLyAyKTtcbiAgICB2YXIgZF95X3VwcGVyID0gTWF0aC5hYnMoKG5vZGUuZGF0YSgnaGVpZ2h0LWJlZm9yZS1maXNoZXllJykgLSBub2RlLm91dGVySGVpZ2h0KCkpIC8gMik7XG4gICAgdmFyIGRfeV9sb3dlciA9IE1hdGguYWJzKChub2RlLmRhdGEoJ2hlaWdodC1iZWZvcmUtZmlzaGV5ZScpIC0gbm9kZS5vdXRlckhlaWdodCgpKSAvIDIpO1xuXG4gICAgdmFyIGFic19kaWZmX29uX3ggPSBNYXRoLmFicyhub2RlLmRhdGEoJ3gtYmVmb3JlLWZpc2hleWUnKSAtIHhfYSk7XG4gICAgdmFyIGFic19kaWZmX29uX3kgPSBNYXRoLmFicyhub2RlLmRhdGEoJ3ktYmVmb3JlLWZpc2hleWUnKSAtIHlfYSk7XG5cbiAgICAvLyBDZW50ZXIgd2VudCB0byBMRUZUXG4gICAgaWYgKG5vZGUuZGF0YSgneC1iZWZvcmUtZmlzaGV5ZScpID4geF9hKSB7XG4gICAgICBkX3hfbGVmdCA9IGRfeF9sZWZ0ICsgYWJzX2RpZmZfb25feDtcbiAgICAgIGRfeF9yaWdodCA9IGRfeF9yaWdodCAtIGFic19kaWZmX29uX3g7XG4gICAgfVxuICAgIC8vIENlbnRlciB3ZW50IHRvIFJJR0hUXG4gICAgZWxzZSB7XG4gICAgICBkX3hfbGVmdCA9IGRfeF9sZWZ0IC0gYWJzX2RpZmZfb25feDtcbiAgICAgIGRfeF9yaWdodCA9IGRfeF9yaWdodCArIGFic19kaWZmX29uX3g7XG4gICAgfVxuXG4gICAgLy8gQ2VudGVyIHdlbnQgdG8gVVBcbiAgICBpZiAobm9kZS5kYXRhKCd5LWJlZm9yZS1maXNoZXllJykgPiB5X2EpIHtcbiAgICAgIGRfeV91cHBlciA9IGRfeV91cHBlciArIGFic19kaWZmX29uX3k7XG4gICAgICBkX3lfbG93ZXIgPSBkX3lfbG93ZXIgLSBhYnNfZGlmZl9vbl95O1xuICAgIH1cbiAgICAvLyBDZW50ZXIgd2VudCB0byBET1dOXG4gICAgZWxzZSB7XG4gICAgICBkX3lfdXBwZXIgPSBkX3lfdXBwZXIgLSBhYnNfZGlmZl9vbl95O1xuICAgICAgZF95X2xvd2VyID0gZF95X2xvd2VyICsgYWJzX2RpZmZfb25feTtcbiAgICB9XG5cbiAgICB2YXIgeFBvc0luUGFyZW50U2libGluZyA9IFtdO1xuICAgIHZhciB5UG9zSW5QYXJlbnRTaWJsaW5nID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpYmxpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB4UG9zSW5QYXJlbnRTaWJsaW5nLnB1c2godGhpcy54UG9zaXRpb25JblBhcmVudChzaWJsaW5nc1tpXSkpO1xuICAgICAgeVBvc0luUGFyZW50U2libGluZy5wdXNoKHRoaXMueVBvc2l0aW9uSW5QYXJlbnQoc2libGluZ3NbaV0pKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpYmxpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2libGluZyA9IHNpYmxpbmdzW2ldO1xuXG4gICAgICB2YXIgeF9iID0geFBvc0luUGFyZW50U2libGluZ1tpXTtcbiAgICAgIHZhciB5X2IgPSB5UG9zSW5QYXJlbnRTaWJsaW5nW2ldO1xuXG4gICAgICB2YXIgc2xvcGUgPSAoeV9iIC0geV9hKSAvICh4X2IgLSB4X2EpO1xuXG4gICAgICB2YXIgZF94ID0gMDtcbiAgICAgIHZhciBkX3kgPSAwO1xuICAgICAgdmFyIFRfeCA9IDA7XG4gICAgICB2YXIgVF95ID0gMDtcblxuICAgICAgLy8gQ3VycmVudCBzaWJsaW5nIGlzIG9uIHRoZSBMRUZUXG4gICAgICBpZiAoeF9hID4geF9iKSB7XG4gICAgICAgIGRfeCA9IGRfeF9sZWZ0O1xuICAgICAgfVxuICAgICAgLy8gQ3VycmVudCBzaWJsaW5nIGlzIG9uIHRoZSBSSUdIVFxuICAgICAgZWxzZSB7XG4gICAgICAgIGRfeCA9IGRfeF9yaWdodDtcbiAgICAgIH1cbiAgICAgIC8vIEN1cnJlbnQgc2libGluZyBpcyBvbiB0aGUgVVBQRVIgc2lkZVxuICAgICAgaWYgKHlfYSA+IHlfYikge1xuICAgICAgICBkX3kgPSBkX3lfdXBwZXI7XG4gICAgICB9XG4gICAgICAvLyBDdXJyZW50IHNpYmxpbmcgaXMgb24gdGhlIExPV0VSIHNpZGVcbiAgICAgIGVsc2Uge1xuICAgICAgICBkX3kgPSBkX3lfbG93ZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Zpbml0ZShzbG9wZSkpIHtcbiAgICAgICAgVF94ID0gTWF0aC5taW4oZF94LCAoZF95IC8gTWF0aC5hYnMoc2xvcGUpKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzbG9wZSAhPT0gMCkge1xuICAgICAgICBUX3kgPSBNYXRoLm1pbihkX3ksIChkX3ggKiBNYXRoLmFicyhzbG9wZSkpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHhfYSA+IHhfYikge1xuICAgICAgICBUX3ggPSAtMSAqIFRfeDtcbiAgICAgIH1cblxuICAgICAgaWYgKHlfYSA+IHlfYikge1xuICAgICAgICBUX3kgPSAtMSAqIFRfeTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5maXNoRXllVmlld01vdmVOb2RlKHNpYmxpbmcsIFRfeCwgVF95LCBub2RlVG9FeHBhbmQsIHNpbmdsZU5vdFNpbXBsZSwgYW5pbWF0ZSwgbGF5b3V0QnkpO1xuICAgIH1cblxuXG4gICAgaWYgKG5vZGUucGFyZW50KClbMF0gIT0gbnVsbCkge1xuICAgICAgdGhpcy5maXNoRXllVmlld0V4cGFuZEdpdmVuTm9kZShub2RlLnBhcmVudCgpWzBdLCBzaW5nbGVOb3RTaW1wbGUsIG5vZGVUb0V4cGFuZCwgYW5pbWF0ZSwgbGF5b3V0QnkpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9LFxuICBnZXRTaWJsaW5nczogZnVuY3Rpb24gKG5vZGUpIHsvLyovL1xuICAgIHZhciBzaWJsaW5ncztcblxuICAgIGlmIChub2RlLnBhcmVudCgpWzBdID09IG51bGwpIHtcbiAgICAgIHNpYmxpbmdzID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgdmFyIG9ycGhhbnMgPSBjeS5ub2RlcygpLm9ycGhhbnMoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcnBoYW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChvcnBoYW5zW2ldICE9IG5vZGUpIHtcbiAgICAgICAgICBzaWJsaW5ncyA9IHNpYmxpbmdzLmFkZChvcnBoYW5zW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzaWJsaW5ncyA9IG5vZGUuc2libGluZ3MoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2libGluZ3M7XG4gIH0sXG4gIC8qXG4gICAqIE1vdmUgbm9kZSBvcGVyYXRpb24gc3BlY2lhbGl6ZWQgZm9yIGZpc2ggZXllIHZpZXcgZXhwYW5kIG9wZXJhdGlvblxuICAgKiBNb3ZlcyB0aGUgbm9kZSBieSBtb3ZpbmcgaXRzIGRlc2NhbmRlbnRzLiBNb3ZlbWVudCBpcyBhbmltYXRlZCBpZiBzaW5nbGVOb3RTaW1wbGUgZmxhZyBpcyB0cnV0aHkuXG4gICAqL1xuICBmaXNoRXllVmlld01vdmVOb2RlOiBmdW5jdGlvbiAobm9kZSwgVF94LCBUX3ksIG5vZGVUb0V4cGFuZCwgc2luZ2xlTm90U2ltcGxlLCBhbmltYXRlLCBsYXlvdXRCeSkgey8vKi8vXG4gICAgdmFyIGNoaWxkcmVuTGlzdCA9IG5vZGUuY2hpbGRyZW4oKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoY2hpbGRyZW5MaXN0Lmxlbmd0aCA9PSAwKSB7XG4gICAgICB2YXIgbmV3UG9zaXRpb24gPSB7eDogbm9kZS5wb3NpdGlvbigneCcpICsgVF94LCB5OiBub2RlLnBvc2l0aW9uKCd5JykgKyBUX3l9O1xuICAgICAgaWYgKCFzaW5nbGVOb3RTaW1wbGUgfHwgIWFuaW1hdGUpIHtcbiAgICAgICAgbm9kZS5wb3NpdGlvbihuZXdQb3NpdGlvbik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5hbmltYXRlZGx5TW92aW5nTm9kZUNvdW50Kys7XG4gICAgICAgIG5vZGUuYW5pbWF0ZSh7XG4gICAgICAgICAgcG9zaXRpb246IG5ld1Bvc2l0aW9uLFxuICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLmFuaW1hdGVkbHlNb3ZpbmdOb2RlQ291bnQtLTtcbiAgICAgICAgICAgIGlmIChzZWxmLmFuaW1hdGVkbHlNb3ZpbmdOb2RlQ291bnQgPiAwIHx8IG5vZGVUb0V4cGFuZC5kYXRhKCdleHBhbmRlZC1jb2xsYXBzZWQnKSA9PT0gJ2V4cGFuZGVkJykge1xuXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5leHBhbmROb2RlQmFzZUZ1bmN0aW9uKG5vZGVUb0V4cGFuZCwgc2luZ2xlTm90U2ltcGxlLCB0cnVlLCBsYXlvdXRCeSk7XG5cbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogMTAwMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZmlzaEV5ZVZpZXdNb3ZlTm9kZShjaGlsZHJlbkxpc3RbaV0sIFRfeCwgVF95LCBub2RlVG9FeHBhbmQsIHNpbmdsZU5vdFNpbXBsZSwgYW5pbWF0ZSwgbGF5b3V0QnkpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgeFBvc2l0aW9uSW5QYXJlbnQ6IGZ1bmN0aW9uIChub2RlKSB7Ly8qLy9cbiAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnQoKVswXTtcbiAgICB2YXIgeF9hID0gMC4wO1xuXG4gICAgLy8gR2l2ZW4gbm9kZSBpcyBub3QgYSBkaXJlY3QgY2hpbGQgb2YgdGhlIHRoZSByb290IGdyYXBoXG4gICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICB4X2EgPSBub2RlLnJlbGF0aXZlUG9zaXRpb24oJ3gnKSArIChwYXJlbnQud2lkdGgoKSAvIDIpO1xuICAgIH1cbiAgICAvLyBHaXZlbiBub2RlIGlzIGEgZGlyZWN0IGNoaWxkIG9mIHRoZSB0aGUgcm9vdCBncmFwaFxuXG4gICAgZWxzZSB7XG4gICAgICB4X2EgPSBub2RlLnBvc2l0aW9uKCd4Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHhfYTtcbiAgfSxcbiAgeVBvc2l0aW9uSW5QYXJlbnQ6IGZ1bmN0aW9uIChub2RlKSB7Ly8qLy9cbiAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnQoKVswXTtcblxuICAgIHZhciB5X2EgPSAwLjA7XG5cbiAgICAvLyBHaXZlbiBub2RlIGlzIG5vdCBhIGRpcmVjdCBjaGlsZCBvZiB0aGUgdGhlIHJvb3QgZ3JhcGhcbiAgICBpZiAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgIC8qY29uc29sZS5sb2coXCJOb2RlIElEOiBcIiArIG5vZGUuaWQoKSk7XG4gICAgICAgY29uc29sZS5sb2coXCJQYXJlbnQgSUQ6IFwiICsgcGFyZW50LmlkKCkpO1xuICAgICAgIGNvbnNvbGUubG9nKFwiUGFyZW50LndpZHRoOiBcIiArIHBhcmVudC53aWR0aCgpKTtcbiAgICAgICBjb25zb2xlLmxvZyhcIlBhcmVudC5oZWlnaHQ6IFwiICsgcGFyZW50LmhlaWdodCgpKTsqL1xuICAgICAgeV9hID0gbm9kZS5yZWxhdGl2ZVBvc2l0aW9uKCd5JykgKyAocGFyZW50LmhlaWdodCgpIC8gMik7XG4gICAgfVxuICAgIC8vIEdpdmVuIG5vZGUgaXMgYSBkaXJlY3QgY2hpbGQgb2YgdGhlIHRoZSByb290IGdyYXBoXG5cbiAgICBlbHNlIHtcbiAgICAgIHlfYSA9IG5vZGUucG9zaXRpb24oJ3knKTtcbiAgICB9XG5cbiAgICByZXR1cm4geV9hO1xuICB9LFxuICAvKlxuICAgKiBmb3IgYWxsIGNoaWxkcmVuIG9mIHRoZSBub2RlIHBhcmFtZXRlciBjYWxsIHRoaXMgbWV0aG9kXG4gICAqIHdpdGggdGhlIHNhbWUgcm9vdCBwYXJhbWV0ZXIsXG4gICAqIHJlbW92ZSB0aGUgY2hpbGQgYW5kIGFkZCB0aGUgcmVtb3ZlZCBjaGlsZCB0byB0aGUgY29sbGFwc2VkY2hpbGRyZW4gZGF0YVxuICAgKiBvZiB0aGUgcm9vdCB0byByZXN0b3JlIHRoZW0gaW4gdGhlIGNhc2Ugb2YgZXhwYW5kYXRpb25cbiAgICogcm9vdC5fcHJpdmF0ZS5kYXRhLmNvbGxhcHNlZENoaWxkcmVuIGtlZXBzIHRoZSBub2RlcyB0byByZXN0b3JlIHdoZW4gdGhlXG4gICAqIHJvb3QgaXMgZXhwYW5kZWRcbiAgICovXG4gIHJlbW92ZUNoaWxkcmVuOiBmdW5jdGlvbiAobm9kZSwgcm9vdCkgey8vKi8vXG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbigpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgdGhpcy5yZW1vdmVDaGlsZHJlbihjaGlsZCwgcm9vdCk7XG4gICAgICB2YXIgcmVtb3ZlZENoaWxkID0gY2hpbGQucmVtb3ZlKCk7XG4gICAgICBpZiAocm9vdC5fcHJpdmF0ZS5kYXRhLmNvbGxhcHNlZENoaWxkcmVuID09IG51bGwpIHtcbiAgICAgICAgcm9vdC5fcHJpdmF0ZS5kYXRhLmNvbGxhcHNlZENoaWxkcmVuID0gcmVtb3ZlZENoaWxkO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJvb3QuX3ByaXZhdGUuZGF0YS5jb2xsYXBzZWRDaGlsZHJlbiA9IHJvb3QuX3ByaXZhdGUuZGF0YS5jb2xsYXBzZWRDaGlsZHJlbi51bmlvbihyZW1vdmVkQ2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLypcbiAgICogVGhpcyBtZXRob2QgbGV0IHRoZSByb290IHBhcmFtZXRlciB0byBiYXJyb3cgdGhlIGVkZ2VzIGNvbm5lY3RlZCB0byB0aGVcbiAgICogY2hpbGQgbm9kZSBvciBhbnkgbm9kZSBpbnNpZGUgY2hpbGQgbm9kZSBpZiB0aGUgYW55IG9uZSB0aGUgc291cmNlIGFuZCB0YXJnZXRcbiAgICogaXMgYW4gb3V0ZXIgbm9kZSBvZiB0aGUgcm9vdCBub2RlIGluIG90aGVyIHdvcmQgaXQgY3JlYXRlIG1ldGEgZWRnZXNcbiAgICovXG4gIGJhcnJvd0VkZ2VzT2Zjb2xsYXBzZWRDaGlsZHJlbjogZnVuY3Rpb24gKHJvb3QsIGNoaWxkTm9kZSkgey8vKi8vXG4gICAgdmFyIGNoaWxkcmVuID0gY2hpbGROb2RlLmNoaWxkcmVuKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICB0aGlzLmJhcnJvd0VkZ2VzT2Zjb2xsYXBzZWRDaGlsZHJlbihyb290LCBjaGlsZCk7XG4gICAgfVxuXG4gICAgdmFyIGVkZ2VzID0gY2hpbGROb2RlLmNvbm5lY3RlZEVkZ2VzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICAgIHZhciBzb3VyY2UgPSBlZGdlLmRhdGEoXCJzb3VyY2VcIik7XG4gICAgICB2YXIgdGFyZ2V0ID0gZWRnZS5kYXRhKFwidGFyZ2V0XCIpO1xuICAgICAgdmFyIHNvdXJjZU5vZGUgPSBlZGdlLnNvdXJjZSgpO1xuICAgICAgdmFyIHRhcmdldE5vZGUgPSBlZGdlLnRhcmdldCgpO1xuICAgICAgdmFyIG5ld0VkZ2UgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIHt9LCBlZGdlLmpzb25zKClbMF0pO1xuXG4gICAgICAvL0luaXRpbGl6ZSB0aGUgbWV0YSBsZXZlbCBvZiB0aGlzIGVkZ2UgaWYgaXQgaXMgbm90IGluaXRpbGl6ZWQgeWV0XG4gICAgICBpZiAodGhpcy5lZGdlc01ldGFMZXZlbHNbZWRnZS5pZCgpXSA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuZWRnZXNNZXRhTGV2ZWxzW2VkZ2UuaWQoKV0gPSAwO1xuICAgICAgfVxuXG4gICAgICAvKklmIHRoZSBlZGdlIGlzIG1ldGEgYW5kIGhhcyBkaWZmZXJlbnQgc291cmNlIGFuZCB0YXJnZXRzIHRoZW4gaGFuZGxlIHRoaXMgY2FzZSBiZWNhdXNlIGlmXG4gICAgICAgKiB0aGUgb3RoZXIgZW5kIG9mIHRoaXMgZWRnZSBpcyByZW1vdmVkIGJlY2F1c2Ugb2YgdGhlIHJlYXNvbiB0aGF0IGl0J3MgcGFyZW50IGlzXG4gICAgICAgKiBiZWluZyBjb2xsYXBzZWQgYW5kIHRoaXMgbm9kZSBpcyBleHBhbmRlZCBiZWZvcmUgb3RoZXIgZW5kIGlzIHN0aWxsIGNvbGxhcHNlZCB0aGlzIGNhdXNlc1xuICAgICAgICogdGhhdCB0aGlzIGVkZ2UgY2Fubm90IGJlIHJlc3RvcmVkIGFzIG9uZSBlbmQgbm9kZSBvZiBpdCBkb2VzIG5vdCBleGlzdHMuXG4gICAgICAgKiBDcmVhdGUgYSBjb2xsYXBzZWQgbWV0YSBlZGdlIGluZm8gZm9yIHRoaXMgZWRnZSBhbmQgYWRkIHRoaXMgaW5mbyB0byBjb2xsYXBzZWRNZXRhRWRnZXNJbmZvXG4gICAgICAgKiBtYXAuIFRoaXMgaW5mbyBpbmNsdWRlcyBjcmVhdGVkV2hpbGVCZWluZ0NvbGxhcHNlZCh0aGUgbm9kZSB3aGljaCBpcyBiZWluZyBjb2xsYXBzZWQpLFxuICAgICAgICogb3RoZXJFbmQodGhlIG90aGVyIGVuZCBvZiB0aGlzIGVkZ2UpIGFuZCBvbGRPd25lcih0aGUgb3duZXIgb2YgdGhpcyBlZGdlIHdoaWNoIHdpbGwgYmVjb21lXG4gICAgICAgKiBhbiBvbGQgb3duZXIgYWZ0ZXIgY29sbGFwc2Ugb3BlcmF0aW9uKVxuICAgICAgICovXG4gICAgICBpZiAodGhpcy5lZGdlc01ldGFMZXZlbHNbZWRnZS5pZCgpXSAhPSAwICYmIHNvdXJjZSAhPSB0YXJnZXQpIHtcbiAgICAgICAgdmFyIG90aGVyRW5kID0gbnVsbDtcbiAgICAgICAgdmFyIG9sZE93bmVyID0gbnVsbDtcbiAgICAgICAgaWYgKHNvdXJjZSA9PSBjaGlsZE5vZGUuaWQoKSkge1xuICAgICAgICAgIG90aGVyRW5kID0gdGFyZ2V0O1xuICAgICAgICAgIG9sZE93bmVyID0gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRhcmdldCA9PSBjaGlsZE5vZGUuaWQoKSkge1xuICAgICAgICAgIG90aGVyRW5kID0gc291cmNlO1xuICAgICAgICAgIG9sZE93bmVyID0gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICAgIGNyZWF0ZWRXaGlsZUJlaW5nQ29sbGFwc2VkOiByb290LmlkKCksXG4gICAgICAgICAgb3RoZXJFbmQ6IG90aGVyRW5kLFxuICAgICAgICAgIG9sZE93bmVyOiBvbGRPd25lclxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5jb2xsYXBzZWRNZXRhRWRnZXNJbmZvW290aGVyRW5kXSA9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5jb2xsYXBzZWRNZXRhRWRnZXNJbmZvW290aGVyRW5kXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbGxhcHNlZE1ldGFFZGdlc0luZm9bcm9vdC5pZCgpXSA9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5jb2xsYXBzZWRNZXRhRWRnZXNJbmZvW3Jvb3QuaWQoKV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICAvL3RoZSBpbmZvcm1hdGlvbiBzaG91bGQgYmUgcmVhY2hhYmxlIGJ5IGVkZ2UgaWQgYW5kIG5vZGUgaWQnc1xuICAgICAgICB0aGlzLmNvbGxhcHNlZE1ldGFFZGdlc0luZm9bcm9vdC5pZCgpXVtvdGhlckVuZF0gPSBpbmZvO1xuICAgICAgICB0aGlzLmNvbGxhcHNlZE1ldGFFZGdlc0luZm9bb3RoZXJFbmRdW3Jvb3QuaWQoKV0gPSBpbmZvO1xuICAgICAgICB0aGlzLmNvbGxhcHNlZE1ldGFFZGdlc0luZm9bZWRnZS5pZCgpXSA9IGluZm87XG4gICAgICB9XG5cbiAgICAgIHZhciByZW1vdmVkRWRnZSA9IGVkZ2UucmVtb3ZlKCk7XG4gICAgICAvL3N0b3JlIHRoZSBkYXRhIG9mIHRoZSBvcmlnaW5hbCBlZGdlXG4gICAgICAvL3RvIHJlc3RvcmUgd2hlbiB0aGUgbm9kZSBpcyBleHBhbmRlZFxuICAgICAgaWYgKHJvb3QuX3ByaXZhdGUuZGF0YS5lZGdlc09mY29sbGFwc2VkQ2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgICByb290Ll9wcml2YXRlLmRhdGEuZWRnZXNPZmNvbGxhcHNlZENoaWxkcmVuID0gcmVtb3ZlZEVkZ2U7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcm9vdC5fcHJpdmF0ZS5kYXRhLmVkZ2VzT2Zjb2xsYXBzZWRDaGlsZHJlbiA9XG4gICAgICAgICAgICAgICAgcm9vdC5fcHJpdmF0ZS5kYXRhLmVkZ2VzT2Zjb2xsYXBzZWRDaGlsZHJlbi51bmlvbihyZW1vdmVkRWRnZSk7XG4gICAgICB9XG5cbiAgICAgIC8vRG8gbm90IGhhbmRsZSB0aGUgaW5uZXIgZWRnZXNcbiAgICAgIGlmICghdGhpcy5pc091dGVyTm9kZShzb3VyY2VOb2RlLCByb290KSAmJiAhdGhpcy5pc091dGVyTm9kZSh0YXJnZXROb2RlLCByb290KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy9JZiB0aGUgY2hhbmdlIHNvdXJjZSBhbmQvb3IgdGFyZ2V0IG9mIHRoZSBlZGdlIGluIHRoZVxuICAgICAgLy9jYXNlIG9mIHRoZXkgYXJlIGVxdWFsIHRvIHRoZSBpZCBvZiB0aGUgY29sbGFwc2VkIGNoaWxkXG4gICAgICBpZiAoc291cmNlID09IGNoaWxkTm9kZS5pZCgpKSB7XG4gICAgICAgIHNvdXJjZSA9IHJvb3QuaWQoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXQgPT0gY2hpbGROb2RlLmlkKCkpIHtcbiAgICAgICAgdGFyZ2V0ID0gcm9vdC5pZCgpO1xuICAgICAgfVxuXG4gICAgICAvL3ByZXBhcmUgdGhlIG5ldyBlZGdlIGJ5IGNoYW5naW5nIHRoZSBvbGRlciBzb3VyY2UgYW5kL29yIHRhcmdldFxuICAgICAgbmV3RWRnZS5kYXRhLnBvcnRzb3VyY2UgPSBzb3VyY2U7XG4gICAgICBuZXdFZGdlLmRhdGEucG9ydHRhcmdldCA9IHRhcmdldDtcbiAgICAgIG5ld0VkZ2UuZGF0YS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBuZXdFZGdlLmRhdGEudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgLy9yZW1vdmUgdGhlIG9sZGVyIGVkZ2UgYW5kIGFkZCB0aGUgbmV3IG9uZVxuICAgICAgY3kuYWRkKG5ld0VkZ2UpO1xuICAgICAgdmFyIG5ld0N5RWRnZSA9IGN5LmVkZ2VzKClbY3kuZWRnZXMoKS5sZW5ndGggLSAxXTtcbiAgICAgIC8vSWYgdGhpcyBlZGdlIGhhcyBub3QgbWV0YSBjbGFzcyBwcm9wZXJ0aWVzIG1ha2UgaXQgbWV0YVxuICAgICAgaWYgKHRoaXMuZWRnZXNNZXRhTGV2ZWxzW25ld0N5RWRnZS5pZCgpXSA9PSAwKSB7XG4gICAgICAgIG5ld0N5RWRnZS5hZGRDbGFzcyhcIm1ldGFcIik7XG4gICAgICB9XG4gICAgICAvL0luY3JlYXNlIHRoZSBtZXRhIGxldmVsIG9mIHRoaXMgZWRnZSBieSAxXG4gICAgICB0aGlzLmVkZ2VzTWV0YUxldmVsc1tuZXdDeUVkZ2UuaWQoKV0rKztcbiAgICAgIG5ld0N5RWRnZS5kYXRhKFwiY29sbGFwc2VkTm9kZUJlZm9yZUJlY2FtaW5nTWV0YVwiLCBjaGlsZE5vZGUuaWQoKSk7XG4gICAgfVxuICB9LFxuICAvKlxuICAgKiBUaGlzIG1ldGhvZCByZXBhaXJzIHRoZSBlZGdlcyBvZiB0aGUgY29sbGFwc2VkIGNoaWxkcmVuIG9mIHRoZSBnaXZlbiBub2RlXG4gICAqIHdoZW4gdGhlIG5vZGUgaXMgYmVpbmcgZXhwYW5kZWQsIHRoZSBtZXRhIGVkZ2VzIGNyZWF0ZWQgd2hpbGUgdGhlIG5vZGUgaXNcbiAgICogYmVpbmcgY29sbGFwc2VkIGFyZSBoYW5kbGVkIGluIHRoaXMgbWV0aG9kXG4gICAqL1xuICByZXBhaXJFZGdlc09mQ29sbGFwc2VkQ2hpbGRyZW46IGZ1bmN0aW9uIChub2RlKSB7IC8vKi8vXG4gICAgdmFyIGVkZ2VzT2Zjb2xsYXBzZWRDaGlsZHJlbiA9IG5vZGUuX3ByaXZhdGUuZGF0YS5lZGdlc09mY29sbGFwc2VkQ2hpbGRyZW47XG4gICAgaWYgKGVkZ2VzT2Zjb2xsYXBzZWRDaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb2xsYXBzZWRNZXRhRWRnZUluZm9PZk5vZGUgPSB0aGlzLmNvbGxhcHNlZE1ldGFFZGdlc0luZm9bbm9kZS5pZCgpXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzT2Zjb2xsYXBzZWRDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgLy9IYW5kbGUgY29sbGFwc2VkIG1ldGEgZWRnZSBpbmZvIGlmIGl0IGlzIHJlcXVpcmVkXG4gICAgICBpZiAoY29sbGFwc2VkTWV0YUVkZ2VJbmZvT2ZOb2RlICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgdGhpcy5jb2xsYXBzZWRNZXRhRWRnZXNJbmZvW2VkZ2VzT2Zjb2xsYXBzZWRDaGlsZHJlbltpXS5fcHJpdmF0ZS5kYXRhLmlkXSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBpbmZvID0gdGhpcy5jb2xsYXBzZWRNZXRhRWRnZXNJbmZvW2VkZ2VzT2Zjb2xsYXBzZWRDaGlsZHJlbltpXS5fcHJpdmF0ZS5kYXRhLmlkXTtcbiAgICAgICAgLy9JZiB0aGUgbWV0YSBlZGdlIGlzIG5vdCBjcmVhdGVkIGJlY2F1c2Ugb2YgdGhlIHJlYXNvbiB0aGF0IHRoaXMgbm9kZSBpcyBjb2xsYXBzZWRcbiAgICAgICAgLy9oYW5kbGUgaXQgYnkgY2hhbmdpbmcgc291cmNlIG9yIHRhcmdldCBvZiByZWxhdGVkIGVkZ2UgZGF0YXNcbiAgICAgICAgaWYgKGluZm8uY3JlYXRlZFdoaWxlQmVpbmdDb2xsYXBzZWQgIT0gbm9kZS5pZCgpKSB7XG4gICAgICAgICAgaWYgKGVkZ2VzT2Zjb2xsYXBzZWRDaGlsZHJlbltpXS5fcHJpdmF0ZS5kYXRhLnNvdXJjZSA9PSBpbmZvLm9sZE93bmVyKSB7XG4gICAgICAgICAgICBlZGdlc09mY29sbGFwc2VkQ2hpbGRyZW5baV0uX3ByaXZhdGUuZGF0YS5zb3VyY2UgPSBpbmZvLmNyZWF0ZWRXaGlsZUJlaW5nQ29sbGFwc2VkO1xuICAgICAgICAgICAgdGhpcy5hbHRlclNvdXJjZU9yVGFyZ2V0T2ZDb2xsYXBzZWRFZGdlKGluZm8uY3JlYXRlZFdoaWxlQmVpbmdDb2xsYXBzZWRcbiAgICAgICAgICAgICAgICAgICAgLCBlZGdlc09mY29sbGFwc2VkQ2hpbGRyZW5baV0uX3ByaXZhdGUuZGF0YS5pZCwgXCJ0YXJnZXRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGVkZ2VzT2Zjb2xsYXBzZWRDaGlsZHJlbltpXS5fcHJpdmF0ZS5kYXRhLnRhcmdldCA9PSBpbmZvLm9sZE93bmVyKSB7XG4gICAgICAgICAgICBlZGdlc09mY29sbGFwc2VkQ2hpbGRyZW5baV0uX3ByaXZhdGUuZGF0YS50YXJnZXQgPSBpbmZvLmNyZWF0ZWRXaGlsZUJlaW5nQ29sbGFwc2VkO1xuICAgICAgICAgICAgdGhpcy5hbHRlclNvdXJjZU9yVGFyZ2V0T2ZDb2xsYXBzZWRFZGdlKGluZm8uY3JlYXRlZFdoaWxlQmVpbmdDb2xsYXBzZWRcbiAgICAgICAgICAgICAgICAgICAgLCBlZGdlc09mY29sbGFwc2VkQ2hpbGRyZW5baV0uX3ByaXZhdGUuZGF0YS5pZCwgXCJzb3VyY2VcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vRGVsZXRlIHRoZSByZWxhdGVkIGNvbGxhcHNlZE1ldGFFZGdlc0luZm8ncyBhcyB0aGV5IGFyZSBoYW5kbGVkXG4gICAgICAgIGRlbGV0ZSB0aGlzLmNvbGxhcHNlZE1ldGFFZGdlc0luZm9baW5mby5jcmVhdGVkV2hpbGVCZWluZ0NvbGxhcHNlZF1baW5mby5vdGhlckVuZF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNvbGxhcHNlZE1ldGFFZGdlc0luZm9baW5mby5vdGhlckVuZF1baW5mby5jcmVhdGVkV2hpbGVCZWluZ0NvbGxhcHNlZF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNvbGxhcHNlZE1ldGFFZGdlc0luZm9bZWRnZXNPZmNvbGxhcHNlZENoaWxkcmVuW2ldLl9wcml2YXRlLmRhdGEuaWRdO1xuICAgICAgfVxuICAgICAgdmFyIG9sZEVkZ2UgPSBjeS5nZXRFbGVtZW50QnlJZChlZGdlc09mY29sbGFwc2VkQ2hpbGRyZW5baV0uX3ByaXZhdGUuZGF0YS5pZCk7XG4gICAgICAvL0lmIHRoZSBlZGdlIGlzIGFscmVhZHkgaW4gdGhlIGdyYXBoIHJlbW92ZSBpdCBhbmQgZGVjcmVhc2UgaXQncyBtZXRhIGxldmVsXG4gICAgICBpZiAob2xkRWRnZSAhPSBudWxsICYmIG9sZEVkZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmVkZ2VzTWV0YUxldmVsc1tlZGdlc09mY29sbGFwc2VkQ2hpbGRyZW5baV0uX3ByaXZhdGUuZGF0YS5pZF0tLTtcbiAgICAgICAgb2xkRWRnZS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKmVkZ2VzT2Zjb2xsYXBzZWRDaGlsZHJlbi5yZXN0b3JlKCk7Ki9cblxuICAgIC8vQ2hlY2sgZm9yIG1ldGEgbGV2ZWxzIG9mIGVkZ2VzIGFuZCBoYW5kbGUgdGhlIGNoYW5nZXNcbiAgICB0aGlzLmVkZ2VzVG9SZXBhaXIgPSB0aGlzLmVkZ2VzVG9SZXBhaXIudW5pb24oZWRnZXNPZmNvbGxhcHNlZENoaWxkcmVuKTtcblxuICAgIG5vZGUuX3ByaXZhdGUuZGF0YS5lZGdlc09mY29sbGFwc2VkQ2hpbGRyZW4gPSBudWxsO1xuICB9LFxuICAvKm5vZGUgaXMgYW4gb3V0ZXIgbm9kZSBvZiByb290XG4gICBpZiByb290IGlzIG5vdCBpdCdzIGFuY2hlc3RvclxuICAgYW5kIGl0IGlzIG5vdCB0aGUgcm9vdCBpdHNlbGYqL1xuICBpc091dGVyTm9kZTogZnVuY3Rpb24gKG5vZGUsIHJvb3QpIHsvLyovL1xuICAgIHZhciB0ZW1wID0gbm9kZTtcbiAgICB3aGlsZSAodGVtcCAhPSBudWxsKSB7XG4gICAgICBpZiAodGVtcCA9PSByb290KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRlbXAgPSB0ZW1wLnBhcmVudCgpWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBhbmRDb2xsYXBzZVV0aWxpdGllczsiLCJ2YXIgZXhwYW5kQ29sbGFwc2VVdGlsaXRpZXMgPSByZXF1aXJlKCcuL2V4cGFuZENvbGxhcHNlVXRpbGl0aWVzJyk7XG5cbjtcbihmdW5jdGlvbiAoKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyByZWdpc3RlcnMgdGhlIGV4dGVuc2lvbiBvbiBhIGN5dG9zY2FwZSBsaWIgcmVmXG4gIHZhciByZWdpc3RlciA9IGZ1bmN0aW9uIChjeXRvc2NhcGUpIHtcblxuICAgIGlmICghY3l0b3NjYXBlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBjYW4ndCByZWdpc3RlciBpZiBjeXRvc2NhcGUgdW5zcGVjaWZpZWRcblxuICAgIHZhciBjeTtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIGxheW91dEJ5OiBudWxsLCAvLyBmb3IgcmVhcnJhbmdlIGFmdGVyIGV4cGFuZC9jb2xsYXBzZVxuICAgICAgZmlzaGV5ZTogdHJ1ZSxcbiAgICAgIGFuaW1hdGU6IHRydWUsXG4gICAgICByZWFkeTogZnVuY3Rpb24gKCkge1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzZXRPcHRpb25zKGZyb20pIHtcbiAgICAgIHZhciB0ZW1wT3B0cyA9IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpXG4gICAgICAgIHRlbXBPcHRzW2tleV0gPSBvcHRpb25zW2tleV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBmcm9tKVxuICAgICAgICBpZiAodGVtcE9wdHMuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICB0ZW1wT3B0c1trZXldID0gZnJvbVtrZXldO1xuICAgICAgcmV0dXJuIHRlbXBPcHRzO1xuICAgIH1cblxuICAgIHZhciB0YXBwZWRCZWZvcmU7XG4gICAgdmFyIHRhcHBlZFRpbWVvdXQ7XG5cbiAgICAvLyBjeS5leHBhbmRDb2xsYXBzZSgpXG4gICAgY3l0b3NjYXBlKFwiY29yZVwiLCBcImV4cGFuZENvbGxhcHNlXCIsIGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICBjeSA9IHRoaXM7XG4gICAgICBvcHRpb25zID0gc2V0T3B0aW9ucyhvcHRzKTtcblxuICAgICAgLy8gdGVzdCBmb3IgZXhwYW5kLWNvbGxhcHNlXG4gICAgICBjeS5vbigndGFwJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciB0YXBwZWROb3cgPSBldmVudC5jeVRhcmdldDtcbiAgICAgICAgaWYgKHRhcHBlZFRpbWVvdXQgJiYgdGFwcGVkQmVmb3JlKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRhcHBlZFRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXBwZWRCZWZvcmUgPT09IHRhcHBlZE5vdykge1xuICAgICAgICAgIHRhcHBlZE5vdy50cmlnZ2VyKCdkb3VibGVUYXAnKTtcbiAgICAgICAgICB0YXBwZWRCZWZvcmUgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcHBlZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRhcHBlZEJlZm9yZSA9IG51bGw7XG4gICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgICB0YXBwZWRCZWZvcmUgPSB0YXBwZWROb3c7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjeS5vbihcImRvdWJsZVRhcFwiLCAnOnBhcmVudCwgW2V4cGFuZGVkLWNvbGxhcHNlZF0nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS5jeVRhcmdldC5kYXRhKFwiZXhwYW5kZWQtY29sbGFwc2VkXCIpID09IFwiY29sbGFwc2VkXCIpIHtcbiAgICAgICAgICBlLmN5VGFyZ2V0LmV4cGFuZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGUuY3lUYXJnZXQuY29sbGFwc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIG9wdGlvbnMucmVhZHkoKTtcblxuICAgIH0pO1xuXG4gICAgLy8gQ29sbGVjdGlvbiBmdW5jdGlvbnNcblxuICAgIC8vIGVsZXMuY29sbGFwc2Uob3B0aW9ucylcbiAgICBjeXRvc2NhcGUoJ2NvbGxlY3Rpb24nLCAnY29sbGFwc2UnLCBmdW5jdGlvbiAob3B0cykge1xuICAgICAgdmFyIGVsZXMgPSB0aGlzLmNvbGxhcHNpYmxlTm9kZXMoKTtcbiAgICAgIHZhciB0ZW1wT3B0aW9ucyA9IHNldE9wdGlvbnMob3B0cyk7XG5cbiAgICAgIHJldHVybiBleHBhbmRDb2xsYXBzZVV0aWxpdGllcy5jb2xsYXBzZUdpdmVuTm9kZXMoZWxlcywgdGVtcE9wdGlvbnMpO1xuICAgIH0pO1xuXG4gICAgLy8gZWxlcy5jb2xsYXBzZUFsbChvcHRpb25zKVxuICAgIGN5dG9zY2FwZSgnY29sbGVjdGlvbicsICdjb2xsYXBzZUFsbCcsIGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICB2YXIgZWxlcyA9IHRoaXMuY29sbGFwc2libGVOb2RlcygpO1xuICAgICAgdmFyIHRlbXBPcHRpb25zID0gc2V0T3B0aW9ucyhvcHRzKTtcblxuICAgICAgcmV0dXJuIGVsZXMudW5pb24oZWxlcy5kZXNjZW5kYW50cygpKS5jb2xsYXBzZSh0ZW1wT3B0aW9ucyk7XG4gICAgfSk7XG5cbiAgICAvLyBlbGVzLmV4cGFuZChvcHRpb25zKVxuICAgIGN5dG9zY2FwZSgnY29sbGVjdGlvbicsICdleHBhbmQnLCBmdW5jdGlvbiAob3B0cykge1xuICAgICAgdmFyIGVsZXMgPSB0aGlzLmV4cGFuZGFibGVOb2RlcygpO1xuICAgICAgdmFyIHRlbXBPcHRpb25zID0gc2V0T3B0aW9ucyhvcHRzKTtcblxuICAgICAgcmV0dXJuIGV4cGFuZENvbGxhcHNlVXRpbGl0aWVzLmV4cGFuZEdpdmVuTm9kZXMoZWxlcywgdGVtcE9wdGlvbnMpO1xuICAgIH0pO1xuXG4gICAgLy8gZWxlcy5leHBhbmRBbGwob3B0aW9ucylcbiAgICBjeXRvc2NhcGUoJ2NvbGxlY3Rpb24nLCAnZXhwYW5kQWxsJywgZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgIHZhciBlbGVzID0gdGhpcy5leHBhbmRhYmxlTm9kZXMoKTtcbiAgICAgIHZhciB0ZW1wT3B0aW9ucyA9IHNldE9wdGlvbnMob3B0cyk7XG5cbiAgICAgIHJldHVybiBleHBhbmRDb2xsYXBzZVV0aWxpdGllcy5leHBhbmRBbGxOb2RlcyhlbGVzLCB0ZW1wT3B0aW9ucyk7XG4gICAgfSk7XG5cblxuICAgIC8vIENvcmUgZnVuY3Rpb25zXG5cbiAgICAvLyBjeS5jb2xsYXBzZUFsbChvcHRpb25zKVxuICAgIGN5dG9zY2FwZSgnY29yZScsICdjb2xsYXBzZUFsbCcsIGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuICAgICAgdmFyIHRlbXBPcHRpb25zID0gc2V0T3B0aW9ucyhvcHRzKTtcblxuICAgICAgcmV0dXJuIGN5Lm5vZGVzKCkuY29sbGFwc2libGVOb2RlcygpLmNvbGxhcHNlQWxsKHRlbXBPcHRpb25zKTtcbiAgICB9KTtcblxuICAgIC8vIGN5LmV4cGFuZEFsbChvcHRpb25zKVxuICAgIGN5dG9zY2FwZSgnY29yZScsICdleHBhbmRBbGwnLCBmdW5jdGlvbiAob3B0cykge1xuICAgICAgdmFyIGN5ID0gdGhpcztcbiAgICAgIHZhciB0ZW1wT3B0aW9ucyA9IHNldE9wdGlvbnMob3B0cyk7XG5cbiAgICAgIHJldHVybiBjeS5ub2RlcygpLmV4cGFuZGFibGVOb2RlcygpLmV4cGFuZEFsbCgpO1xuICAgIH0pO1xuXG5cbiAgICAvLyBVdGlsaXR5IGZ1bmN0aW9uc1xuXG4gICAgLy8gZWxlLmlzQ29sbGFwc2libGUoKVxuICAgIGN5dG9zY2FwZSgnY29sbGVjdGlvbicsICdpc0V4cGFuZGFibGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZWxlID0gdGhpcztcblxuICAgICAgcmV0dXJuIChlbGUuZGF0YShcImV4cGFuZGVkLWNvbGxhcHNlZFwiKSA9PT0gXCJjb2xsYXBzZWRcIik7XG4gICAgfSk7XG5cbiAgICAvLyBlbGUuaXNFeHBhbmRhYmxlKClcbiAgICBjeXRvc2NhcGUoJ2NvbGxlY3Rpb24nLCAnaXNDb2xsYXBzaWJsZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzO1xuICAgICAgcmV0dXJuICFlbGUuaXNFeHBhbmRhYmxlKCkgJiYgZWxlLmlzUGFyZW50KCk7XG4gICAgfSk7XG5cbiAgICAvLyBlbGVzLmNvbGxhcHNlZCgpXG4gICAgY3l0b3NjYXBlKCdjb2xsZWN0aW9uJywgJ2NvbGxhcHNpYmxlTm9kZXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBlbGVzLmZpbHRlcihmdW5jdGlvbiAoaSwgZWxlKSB7XG4gICAgICAgIHJldHVybiBlbGUuaXNDb2xsYXBzaWJsZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBlbGVzLmV4cGFuZGVkKClcbiAgICBjeXRvc2NhcGUoJ2NvbGxlY3Rpb24nLCAnZXhwYW5kYWJsZU5vZGVzJywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gZWxlcy5maWx0ZXIoZnVuY3Rpb24gKGksIGVsZSkge1xuICAgICAgICByZXR1cm4gZWxlLmlzRXhwYW5kYWJsZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7IC8vIGV4cG9zZSBhcyBhIGNvbW1vbmpzIG1vZHVsZVxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVnaXN0ZXI7XG4gIH1cblxuICBpZiAodHlwZW9mIGRlZmluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lLmFtZCkgeyAvLyBleHBvc2UgYXMgYW4gYW1kL3JlcXVpcmVqcyBtb2R1bGVcbiAgICBkZWZpbmUoJ2N5dG9zY2FwZS1leHBhbmQtY29sbGFwc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVnaXN0ZXI7XG4gICAgfSk7XG4gIH1cblxuICBpZiAodHlwZW9mIGN5dG9zY2FwZSAhPT0gJ3VuZGVmaW5lZCcpIHsgLy8gZXhwb3NlIHRvIGdsb2JhbCBjeXRvc2NhcGUgKGkuZS4gd2luZG93LmN5dG9zY2FwZSlcbiAgICByZWdpc3RlcihjeXRvc2NhcGUpO1xuICB9XG5cbn0pKCk7XG4iXX0=
